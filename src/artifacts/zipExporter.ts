import JSZip from 'jszip';
import { ProjectFiles } from './types';
import {
  generateIndexHtml,
  generateViteConfig,
  generateTsConfig,
  generatePackageJson,
  generateMainTsx,
  generateIndexCss,
  generateAppTsx,
  generateReadme,
  RUNTIME_SOURCE,
  IR_TYPES_SOURCE,
  IR_COMPILER_SOURCE,
  RUNTIME_ENGINE_SOURCE
} from '../project-template/templates';
import { StandaloneGenerator } from '../manifest/standalone-generator';
import { Parser } from '../manifest/parser';

export function generateProjectName(source: string): string {
  const moduleMatch = source.match(/module\s+(\w+)/);
  const entityMatch = source.match(/entity\s+(\w+)/);
  const name = moduleMatch?.[1] || entityMatch?.[1] || 'manifest';
  return name.toLowerCase();
}

export function buildFileMap(files: ProjectFiles): Record<string, string> {
  const projectName = generateProjectName(files.source);

  return {
    'src/generated/client.ts': files.clientCode || '// No client code generated',
    'src/generated/server.ts': files.serverCode || '// No server code generated (add "server" to expose declarations)',
    'src/generated/tests.spec.ts': files.testCode || '// No tests generated',
    'src/generated/ast.json': JSON.stringify(files.ast, null, 2) || '{}',
    'manifest/source.manifest': files.source,
    'package.json': JSON.stringify({
      name: projectName,
      version: '1.0.0',
      type: 'module',
      scripts: {
        build: 'tsc',
        test: 'vitest run',
        dev: 'tsx src/generated/client.ts'
      },
      devDependencies: {
        typescript: '^5.5.0',
        vitest: '^2.0.0',
        tsx: '^4.0.0'
      }
    }, null, 2),
    'tsconfig.json': JSON.stringify({
      compilerOptions: {
        target: 'ES2022',
        module: 'ESNext',
        moduleResolution: 'bundler',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        declaration: true,
        outDir: './dist',
        rootDir: './src'
      },
      include: ['src/**/*']
    }, null, 2),
    'README.md': `# ${projectName}\n\nGenerated by Manifest Compiler v2.0\n\n## Quick Start\n\n\`\`\`bash\nnpm install\nnpm run build\nnpm test\n\`\`\`\n`
  };
}

export function buildRunnableProjectFiles(files: ProjectFiles): Record<string, string> {
  const projectName = generateProjectName(files.source);
  const parser = new Parser();
  const { program, errors } = parser.parse(files.source);

  let generatedCode = '// Failed to generate code';
  if (errors.length === 0) {
    const generator = new StandaloneGenerator();
    generatedCode = generator.generate(program);
  }

  return {
    'index.html': generateIndexHtml(projectName),
    'vite.config.ts': generateViteConfig(),
    'tsconfig.json': generateTsConfig(),
    'package.json': generatePackageJson(projectName),
    'README.md': generateReadme(projectName),
    'src/main.tsx': generateMainTsx(),
    'src/index.css': generateIndexCss(),
    'src/App.tsx': generateAppTsx(),
    'src/manifest/source.manifest': files.source,
    'src/manifest/runtime.ts': RUNTIME_SOURCE,
    'src/manifest/generated.ts': generatedCode,
    'src/manifest/compiler/types.ts': COMPILER_TYPES_SOURCE,
    'src/manifest/compiler/lexer.ts': COMPILER_LEXER_SOURCE,
    'src/manifest/compiler/parser.ts': COMPILER_PARSER_SOURCE,
    'src/manifest/compiler/generator.ts': COMPILER_GENERATOR_SOURCE,
    'src/manifest/compiler/index.ts': COMPILER_INDEX_SOURCE,
    'src/manifest/ir/types.ts': IR_TYPES_SOURCE,
    'src/manifest/ir/ir-compiler.ts': IR_COMPILER_SOURCE,
    'src/manifest/ir/runtime-engine.ts': RUNTIME_ENGINE_SOURCE,
    'src/vite-env.d.ts': '/// <reference types="vite/client" />'
  };
}

export async function exportZip(files: ProjectFiles): Promise<void> {
  const zip = new JSZip();
  const fileMap = buildFileMap(files);
  const projectName = generateProjectName(files.source);
  const timestamp = new Date().toISOString().slice(0, 10);

  for (const [path, content] of Object.entries(fileMap)) {
    zip.file(path, content);
  }

  const blob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `manifest-${projectName}-${timestamp}.zip`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

export async function exportRunnableZip(files: ProjectFiles): Promise<void> {
  const zip = new JSZip();
  const fileMap = buildRunnableProjectFiles(files);
  const projectName = generateProjectName(files.source);
  const timestamp = new Date().toISOString().slice(0, 10);

  for (const [path, content] of Object.entries(fileMap)) {
    zip.file(path, content);
  }

  const blob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `manifest-${projectName}-runnable-${timestamp}.zip`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

export function copyToClipboard(text: string): Promise<void> {
  return navigator.clipboard.writeText(text);
}

export function copyAllFiles(files: ProjectFiles): Promise<void> {
  const fileMap = buildFileMap(files);
  return copyToClipboard(JSON.stringify(fileMap, null, 2));
}

const COMPILER_TYPES_SOURCE = `export interface Position {
  line: number;
  column: number;
}

export interface Token {
  type: 'KEYWORD' | 'IDENTIFIER' | 'STRING' | 'NUMBER' | 'OPERATOR' | 'PUNCTUATION' | 'NEWLINE' | 'EOF';
  value: string;
  position: Position;
}

export interface ASTNode {
  type: string;
  position?: Position;
}

export interface ModuleNode extends ASTNode {
  type: 'Module';
  name: string;
  entities: EntityNode[];
  commands: CommandNode[];
  policies: PolicyNode[];
  stores: StoreNode[];
  events: OutboxEventNode[];
}

export interface EntityNode extends ASTNode {
  type: 'Entity';
  name: string;
  properties: PropertyNode[];
  computedProperties: ComputedPropertyNode[];
  relationships: RelationshipNode[];
  behaviors: BehaviorNode[];
  commands: CommandNode[];
  constraints: ConstraintNode[];
  policies: PolicyNode[];
  store?: string;
}

export interface PropertyNode extends ASTNode {
  type: 'Property';
  name: string;
  dataType: TypeNode;
  defaultValue?: ExpressionNode;
  modifiers: string[];
}

export interface ComputedPropertyNode extends ASTNode {
  type: 'ComputedProperty';
  name: string;
  dataType: TypeNode;
  expression: ExpressionNode;
  dependencies: string[];
}

export interface RelationshipNode extends ASTNode {
  type: 'Relationship';
  kind: 'hasMany' | 'hasOne' | 'belongsTo' | 'ref';
  name: string;
  target: string;
  foreignKey?: string;
  through?: string;
}

export interface CommandNode extends ASTNode {
  type: 'Command';
  name: string;
  parameters: ParameterNode[];
  guards?: ExpressionNode[];
  actions: ActionNode[];
  emits?: string[];
  returns?: TypeNode;
}

export interface ParameterNode extends ASTNode {
  type: 'Parameter';
  name: string;
  dataType: TypeNode;
  required: boolean;
  defaultValue?: ExpressionNode;
}

export interface PolicyNode extends ASTNode {
  type: 'Policy';
  name: string;
  action: 'read' | 'write' | 'delete' | 'execute' | 'all';
  expression: ExpressionNode;
  message?: string;
}

export interface StoreNode extends ASTNode {
  type: 'Store';
  entity: string;
  target: 'memory' | 'postgres' | 'supabase' | 'localStorage';
  config?: Record<string, ExpressionNode>;
}

export interface OutboxEventNode extends ASTNode {
  type: 'OutboxEvent';
  name: string;
  channel: string;
  payload: TypeNode | { fields: ParameterNode[] };
}

export interface TypeNode extends ASTNode {
  type: 'Type';
  name: string;
  generic?: TypeNode;
  nullable: boolean;
}

export interface BehaviorNode extends ASTNode {
  type: 'Behavior';
  name: string;
  trigger: TriggerNode;
  actions: ActionNode[];
  guards?: ExpressionNode[];
}

export interface TriggerNode extends ASTNode {
  type: 'Trigger';
  event: string;
  parameters?: string[];
}

export interface ActionNode extends ASTNode {
  type: 'Action';
  kind: 'mutate' | 'emit' | 'compute' | 'effect' | 'publish' | 'persist';
  target?: string;
  expression: ExpressionNode;
}

export interface ConstraintNode extends ASTNode {
  type: 'Constraint';
  name: string;
  expression: ExpressionNode;
  message?: string;
}

export interface FlowNode extends ASTNode {
  type: 'Flow';
  name: string;
  input: TypeNode;
  output: TypeNode;
  steps: FlowStepNode[];
}

export interface FlowStepNode extends ASTNode {
  type: 'FlowStep';
  operation: string;
  expression: ExpressionNode;
  condition?: ExpressionNode;
}

export interface EffectNode extends ASTNode {
  type: 'Effect';
  name: string;
  kind: 'http' | 'storage' | 'timer' | 'event' | 'custom';
  config: Record<string, ExpressionNode>;
}

export interface ExposeNode extends ASTNode {
  type: 'Expose';
  name: string;
  protocol: 'rest' | 'graphql' | 'websocket' | 'function';
  entity: string;
  operations: string[];
  generateServer: boolean;
  middleware?: string[];
}

export interface CompositionNode extends ASTNode {
  type: 'Composition';
  name: string;
  components: ComponentRefNode[];
  connections: ConnectionNode[];
}

export interface ComponentRefNode extends ASTNode {
  type: 'ComponentRef';
  entity: string;
  alias?: string;
  config?: Record<string, ExpressionNode>;
}

export interface ConnectionNode extends ASTNode {
  type: 'Connection';
  from: { component: string; output: string };
  to: { component: string; input: string };
  transform?: ExpressionNode;
}

export type ExpressionNode =
  | LiteralNode
  | IdentifierNode
  | BinaryOpNode
  | UnaryOpNode
  | CallNode
  | MemberAccessNode
  | ConditionalNode
  | ArrayNode
  | ObjectNode
  | LambdaNode;

export interface LiteralNode extends ASTNode {
  type: 'Literal';
  value: string | number | boolean | null;
  dataType: 'string' | 'number' | 'boolean' | 'null';
}

export interface IdentifierNode extends ASTNode {
  type: 'Identifier';
  name: string;
}

export interface BinaryOpNode extends ASTNode {
  type: 'BinaryOp';
  operator: string;
  left: ExpressionNode;
  right: ExpressionNode;
}

export interface UnaryOpNode extends ASTNode {
  type: 'UnaryOp';
  operator: string;
  operand: ExpressionNode;
}

export interface CallNode extends ASTNode {
  type: 'Call';
  callee: ExpressionNode;
  arguments: ExpressionNode[];
}

export interface MemberAccessNode extends ASTNode {
  type: 'MemberAccess';
  object: ExpressionNode;
  property: string;
}

export interface ConditionalNode extends ASTNode {
  type: 'Conditional';
  condition: ExpressionNode;
  consequent: ExpressionNode;
  alternate: ExpressionNode;
}

export interface ArrayNode extends ASTNode {
  type: 'Array';
  elements: ExpressionNode[];
}

export interface ObjectNode extends ASTNode {
  type: 'Object';
  properties: { key: string; value: ExpressionNode }[];
}

export interface LambdaNode extends ASTNode {
  type: 'Lambda';
  parameters: string[];
  body: ExpressionNode;
}

export interface ManifestProgram {
  modules: ModuleNode[];
  entities: EntityNode[];
  commands: CommandNode[];
  flows: FlowNode[];
  effects: EffectNode[];
  exposures: ExposeNode[];
  compositions: CompositionNode[];
  policies: PolicyNode[];
  stores: StoreNode[];
  events: OutboxEventNode[];
}

export interface CompilationResult {
  success: boolean;
  code?: string;
  serverCode?: string;
  testCode?: string;
  errors?: CompilationError[];
  ast?: ManifestProgram;
}

export interface CompilationError {
  message: string;
  position?: Position;
  severity: 'error' | 'warning';
}
`;

const COMPILER_LEXER_SOURCE = `import { Token, Position } from './types';

const KEYWORDS = new Set([
  'entity', 'property', 'behavior', 'constraint', 'flow', 'effect', 'expose', 'compose',
  'command', 'module', 'policy', 'store', 'event', 'computed', 'derived',
  'hasMany', 'hasOne', 'belongsTo', 'ref', 'through',
  'on', 'when', 'then', 'emit', 'mutate', 'compute', 'guard', 'publish', 'persist',
  'as', 'from', 'to', 'with', 'where', 'connect', 'returns',
  'string', 'number', 'boolean', 'list', 'map', 'any', 'void',
  'true', 'false', 'null',
  'required', 'unique', 'indexed', 'private', 'readonly', 'optional',
  'rest', 'graphql', 'websocket', 'function', 'server',
  'http', 'storage', 'timer', 'custom',
  'memory', 'postgres', 'supabase', 'localStorage',
  'read', 'write', 'delete', 'execute', 'all', 'allow', 'deny',
  'and', 'or', 'not', 'is', 'in', 'contains',
  'user', 'self', 'context'
]);

const OPERATORS = new Set([
  '+', '-', '*', '/', '%', '=', '==', '!=', '<', '>', '<=', '>=',
  '&&', '||', '!', '?', ':', '->', '=>', '|', '&', '.', '..', '?.'
]);

const PUNCTUATION = new Set(['(', ')', '{', '}', '[', ']', ',', ';', '@']);

export class Lexer {
  private source: string;
  private pos = 0;
  private line = 1;
  private col = 1;
  private tokens: Token[] = [];

  constructor(source: string) {
    this.source = source;
  }

  tokenize(): Token[] {
    while (this.pos < this.source.length) {
      this.skipWhitespace();
      if (this.pos >= this.source.length) break;

      const char = this.source[this.pos];

      if (char === '\\n') {
        this.tokens.push({ type: 'NEWLINE', value: '\\n', position: this.position() });
        this.advance();
        this.line++;
        this.col = 1;
        continue;
      }

      if (char === '"' || char === "'") { this.readString(char); continue; }
      if (char === '\`') { this.readTemplate(); continue; }
      if (this.isDigit(char)) { this.readNumber(); continue; }
      if (this.isAlpha(char) || char === '_') { this.readIdentifier(); continue; }
      if (this.isOpStart(char)) { this.readOperator(); continue; }
      if (PUNCTUATION.has(char)) {
        this.tokens.push({ type: 'PUNCTUATION', value: char, position: this.position() });
        this.advance();
        continue;
      }
      this.advance();
    }

    this.tokens.push({ type: 'EOF', value: '', position: this.position() });
    return this.tokens;
  }

  private skipWhitespace() {
    while (this.pos < this.source.length) {
      const c = this.source[this.pos];
      if (c === ' ' || c === '\\t' || c === '\\r') { this.advance(); continue; }
      if (c === '/' && this.source[this.pos + 1] === '/') {
        while (this.pos < this.source.length && this.source[this.pos] !== '\\n') this.advance();
        continue;
      }
      if (c === '/' && this.source[this.pos + 1] === '*') {
        this.advance(); this.advance();
        while (this.pos < this.source.length && !(this.source[this.pos] === '*' && this.source[this.pos + 1] === '/')) {
          if (this.source[this.pos] === '\\n') { this.line++; this.col = 0; }
          this.advance();
        }
        this.advance(); this.advance();
        continue;
      }
      break;
    }
  }

  private readString(quote: string) {
    this.advance();
    let value = '';
    while (this.pos < this.source.length && this.source[this.pos] !== quote) {
      if (this.source[this.pos] === '\\\\') {
        this.advance();
        const esc = this.source[this.pos];
        value += esc === 'n' ? '\\n' : esc === 't' ? '\\t' : esc;
      } else {
        value += this.source[this.pos];
      }
      this.advance();
    }
    this.advance();
    this.tokens.push({ type: 'STRING', value, position: this.position() });
  }

  private readTemplate() {
    this.advance();
    let value = '';
    while (this.pos < this.source.length && this.source[this.pos] !== '\`') {
      if (this.source[this.pos] === '\\n') { this.line++; this.col = 0; }
      value += this.source[this.pos];
      this.advance();
    }
    this.advance();
    this.tokens.push({ type: 'STRING', value, position: this.position() });
  }

  private readNumber() {
    let value = '';
    while (this.pos < this.source.length && (this.isDigit(this.source[this.pos]) || this.source[this.pos] === '.')) {
      value += this.source[this.pos];
      this.advance();
    }
    this.tokens.push({ type: 'NUMBER', value, position: this.position() });
  }

  private readIdentifier() {
    let value = '';
    while (this.pos < this.source.length && (this.isAlphaNum(this.source[this.pos]) || this.source[this.pos] === '_')) {
      value += this.source[this.pos];
      this.advance();
    }
    this.tokens.push({ type: KEYWORDS.has(value) ? 'KEYWORD' : 'IDENTIFIER', value, position: this.position() });
  }

  private readOperator() {
    const two = this.source.slice(this.pos, this.pos + 2);
    if (OPERATORS.has(two)) {
      this.tokens.push({ type: 'OPERATOR', value: two, position: this.position() });
      this.advance(); this.advance();
    } else {
      this.tokens.push({ type: 'OPERATOR', value: this.source[this.pos], position: this.position() });
      this.advance();
    }
  }

  private isDigit(c: string) { return c >= '0' && c <= '9'; }
  private isAlpha(c: string) { return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'); }
  private isAlphaNum(c: string) { return this.isAlpha(c) || this.isDigit(c); }
  private isOpStart(c: string) { return OPERATORS.has(c) || OPERATORS.has(c + this.source[this.pos + 1]); }
  private advance() { this.pos++; this.col++; }
  private position(): Position { return { line: this.line, column: this.col }; }
}
`;

const COMPILER_PARSER_SOURCE = `import { Lexer } from './lexer';
import {
  Token, ManifestProgram, EntityNode, PropertyNode, TypeNode, BehaviorNode,
  ConstraintNode, FlowNode, FlowStepNode, EffectNode, ExposeNode, CompositionNode,
  ComponentRefNode, ConnectionNode, ExpressionNode, TriggerNode, ActionNode, CompilationError,
  CommandNode, ParameterNode, PolicyNode, StoreNode, OutboxEventNode, ModuleNode,
  ComputedPropertyNode, RelationshipNode
} from './types';

export class Parser {
  private tokens: Token[] = [];
  private pos = 0;
  private errors: CompilationError[] = [];

  parse(source: string): { program: ManifestProgram; errors: CompilationError[] } {
    this.tokens = new Lexer(source).tokenize();
    this.pos = 0;
    this.errors = [];

    const program: ManifestProgram = {
      modules: [], entities: [], commands: [], flows: [], effects: [],
      exposures: [], compositions: [], policies: [], stores: [], events: []
    };

    while (!this.isEnd()) {
      this.skipNL();
      if (this.isEnd()) break;
      try {
        if (this.check('KEYWORD', 'module')) program.modules.push(this.parseModule());
        else if (this.check('KEYWORD', 'entity')) program.entities.push(this.parseEntity());
        else if (this.check('KEYWORD', 'command')) program.commands.push(this.parseCommand());
        else if (this.check('KEYWORD', 'flow')) program.flows.push(this.parseFlow());
        else if (this.check('KEYWORD', 'effect')) program.effects.push(this.parseEffect());
        else if (this.check('KEYWORD', 'expose')) program.exposures.push(this.parseExpose());
        else if (this.check('KEYWORD', 'compose')) program.compositions.push(this.parseComposition());
        else if (this.check('KEYWORD', 'policy')) program.policies.push(this.parsePolicy());
        else if (this.check('KEYWORD', 'store')) program.stores.push(this.parseStore());
        else if (this.check('KEYWORD', 'event')) program.events.push(this.parseOutboxEvent());
        else this.advance();
      } catch (e) {
        this.errors.push({ message: e instanceof Error ? e.message : 'Parse error', position: this.current()?.position, severity: 'error' });
        this.sync();
      }
    }
    return { program, errors: this.errors };
  }

  private parseModule(): ModuleNode {
    this.consume('KEYWORD', 'module');
    const name = this.consume('IDENTIFIER').value;
    this.consume('PUNCTUATION', '{');
    this.skipNL();

    const entities: EntityNode[] = [], commands: CommandNode[] = [], policies: PolicyNode[] = [], stores: StoreNode[] = [], events: OutboxEventNode[] = [];

    while (!this.check('PUNCTUATION', '}') && !this.isEnd()) {
      this.skipNL();
      if (this.check('PUNCTUATION', '}')) break;
      if (this.check('KEYWORD', 'entity')) entities.push(this.parseEntity());
      else if (this.check('KEYWORD', 'command')) commands.push(this.parseCommand());
      else if (this.check('KEYWORD', 'policy')) policies.push(this.parsePolicy());
      else if (this.check('KEYWORD', 'store')) stores.push(this.parseStore());
      else if (this.check('KEYWORD', 'event')) events.push(this.parseOutboxEvent());
      else this.advance();
      this.skipNL();
    }
    this.consume('PUNCTUATION', '}');
    return { type: 'Module', name, entities, commands, policies, stores, events };
  }

  private parseEntity(): EntityNode {
    this.consume('KEYWORD', 'entity');
    const name = this.consume('IDENTIFIER').value;
    this.consume('PUNCTUATION', '{');
    this.skipNL();

    const properties: PropertyNode[] = [], computedProperties: ComputedPropertyNode[] = [], relationships: RelationshipNode[] = [];
    const behaviors: BehaviorNode[] = [], commands: CommandNode[] = [], constraints: ConstraintNode[] = [], policies: PolicyNode[] = [];
    let store: string | undefined;

    while (!this.check('PUNCTUATION', '}') && !this.isEnd()) {
      this.skipNL();
      if (this.check('PUNCTUATION', '}')) break;

      if (this.check('KEYWORD', 'property')) properties.push(this.parseProperty());
      else if (this.check('KEYWORD', 'computed') || this.check('KEYWORD', 'derived')) computedProperties.push(this.parseComputedProperty());
      else if (this.check('KEYWORD', 'hasMany') || this.check('KEYWORD', 'hasOne') || this.check('KEYWORD', 'belongsTo') || this.check('KEYWORD', 'ref')) relationships.push(this.parseRelationship());
      else if (this.check('KEYWORD', 'behavior') || this.check('KEYWORD', 'on')) behaviors.push(this.parseBehavior());
      else if (this.check('KEYWORD', 'command')) commands.push(this.parseCommand());
      else if (this.check('KEYWORD', 'constraint')) constraints.push(this.parseConstraint());
      else if (this.check('KEYWORD', 'policy')) policies.push(this.parsePolicy());
      else if (this.check('KEYWORD', 'store')) { this.advance(); store = this.advance().value; }
      else this.advance();
      this.skipNL();
    }
    this.consume('PUNCTUATION', '}');
    return { type: 'Entity', name, properties, computedProperties, relationships, behaviors, commands, constraints, policies, store };
  }

  private parseProperty(): PropertyNode {
    this.consume('KEYWORD', 'property');
    const modifiers: string[] = [];
    while (['required', 'unique', 'indexed', 'private', 'readonly', 'optional'].includes(this.current()?.value || '')) {
      modifiers.push(this.advance().value);
    }
    const name = this.consume('IDENTIFIER').value;
    this.consume('OPERATOR', ':');
    const dataType = this.parseType();
    let defaultValue: ExpressionNode | undefined;
    if (this.check('OPERATOR', '=')) { this.advance(); defaultValue = this.parseExpr(); }
    return { type: 'Property', name, dataType, defaultValue, modifiers };
  }

  private parseComputedProperty(): ComputedPropertyNode {
    this.advance();
    const name = this.consume('IDENTIFIER').value;
    this.consume('OPERATOR', ':');
    const dataType = this.parseType();
    this.consume('OPERATOR', '=');
    const expression = this.parseExpr();
    const dependencies = this.extractDependencies(expression);
    return { type: 'ComputedProperty', name, dataType, expression, dependencies };
  }

  private extractDependencies(expr: ExpressionNode): string[] {
    const deps = new Set<string>();
    const walk = (e: ExpressionNode) => {
      if (e.type === 'Identifier' && !['self', 'this', 'user', 'context'].includes((e as any).name)) deps.add((e as any).name);
      if (e.type === 'MemberAccess') { walk((e as any).object); }
      if (e.type === 'BinaryOp') { walk((e as any).left); walk((e as any).right); }
      if (e.type === 'UnaryOp') walk((e as any).operand);
      if (e.type === 'Call') { walk((e as any).callee); (e as any).arguments.forEach(walk); }
      if (e.type === 'Conditional') { walk((e as any).condition); walk((e as any).consequent); walk((e as any).alternate); }
      if (e.type === 'Array') (e as any).elements.forEach(walk);
      if (e.type === 'Object') (e as any).properties.forEach((p: any) => walk(p.value));
      if (e.type === 'Lambda') walk((e as any).body);
    };
    walk(expr);
    return Array.from(deps);
  }

  private parseRelationship(): RelationshipNode {
    const kind = this.advance().value as RelationshipNode['kind'];
    const name = this.consume('IDENTIFIER').value;
    this.consume('OPERATOR', ':');
    const target = this.consume('IDENTIFIER').value;
    let foreignKey: string | undefined, through: string | undefined;
    if (this.check('KEYWORD', 'through')) { this.advance(); through = this.consume('IDENTIFIER').value; }
    if (this.check('KEYWORD', 'with')) { this.advance(); foreignKey = this.consume('IDENTIFIER').value; }
    return { type: 'Relationship', kind, name, target, foreignKey, through };
  }

  private parseCommand(): CommandNode {
    this.consume('KEYWORD', 'command');
    const name = this.consume('IDENTIFIER').value;
    this.consume('PUNCTUATION', '(');
    const parameters: ParameterNode[] = [];
    while (!this.check('PUNCTUATION', ')') && !this.isEnd()) {
      const required = !this.check('KEYWORD', 'optional');
      if (!required) this.advance();
      const pname = this.consume('IDENTIFIER').value;
      this.consume('OPERATOR', ':');
      const dataType = this.parseType();
      let defaultValue: ExpressionNode | undefined;
      if (this.check('OPERATOR', '=')) { this.advance(); defaultValue = this.parseExpr(); }
      parameters.push({ type: 'Parameter', name: pname, dataType, required, defaultValue });
      if (this.check('PUNCTUATION', ',')) this.advance();
    }
    this.consume('PUNCTUATION', ')');

    let returns: TypeNode | undefined;
    if (this.check('KEYWORD', 'returns')) { this.advance(); returns = this.parseType(); }

    const guards: ExpressionNode[] = [], actions: ActionNode[] = [], emits: string[] = [];

    if (this.check('PUNCTUATION', '{')) {
      this.advance(); this.skipNL();
      while (!this.check('PUNCTUATION', '}') && !this.isEnd()) {
        this.skipNL();
        if (this.check('PUNCTUATION', '}')) break;
        if (this.check('KEYWORD', 'guard') || this.check('KEYWORD', 'when')) { this.advance(); guards.push(this.parseExpr()); }
        else if (this.check('KEYWORD', 'emit')) { this.advance(); emits.push(this.consume('IDENTIFIER').value); }
        else actions.push(this.parseAction());
        this.skipNL();
      }
      this.consume('PUNCTUATION', '}');
    } else if (this.check('OPERATOR', '=>')) {
      this.advance();
      actions.push(this.parseAction());
    }

    return { type: 'Command', name, parameters, guards: guards.length ? guards : undefined, actions, emits: emits.length ? emits : undefined, returns };
  }

  private parsePolicy(): PolicyNode {
    this.consume('KEYWORD', 'policy');
    const name = this.consume('IDENTIFIER').value;
    let action: PolicyNode['action'] = 'all';
    if (this.check('KEYWORD', 'read') || this.check('KEYWORD', 'write') || this.check('KEYWORD', 'delete') || this.check('KEYWORD', 'execute') || this.check('KEYWORD', 'all')) {
      action = this.advance().value as PolicyNode['action'];
    }
    this.consume('OPERATOR', ':');
    const expression = this.parseExpr();
    const message = this.check('STRING') ? this.advance().value : undefined;
    return { type: 'Policy', name, action, expression, message };
  }

  private parseStore(): StoreNode {
    this.consume('KEYWORD', 'store');
    const entity = this.consume('IDENTIFIER').value;
    this.consume('KEYWORD', 'in');
    const target = this.advance().value as StoreNode['target'];
    const config: Record<string, ExpressionNode> = {};
    if (this.check('PUNCTUATION', '{')) {
      this.advance(); this.skipNL();
      while (!this.check('PUNCTUATION', '}') && !this.isEnd()) {
        this.skipNL();
        if (this.check('PUNCTUATION', '}')) break;
        const key = this.consume('IDENTIFIER').value;
        this.consume('OPERATOR', ':');
        config[key] = this.parseExpr();
        this.skipNL();
      }
      this.consume('PUNCTUATION', '}');
    }
    return { type: 'Store', entity, target, config: Object.keys(config).length ? config : undefined };
  }

  private parseOutboxEvent(): OutboxEventNode {
    this.consume('KEYWORD', 'event');
    const name = this.consume('IDENTIFIER').value;
    this.consume('OPERATOR', ':');
    const channel = this.check('STRING') ? this.advance().value : name;
    let payload: OutboxEventNode['payload'] = { type: 'Type', name: 'any', nullable: false };
    if (this.check('PUNCTUATION', '{')) {
      this.advance(); this.skipNL();
      const fields: ParameterNode[] = [];
      while (!this.check('PUNCTUATION', '}') && !this.isEnd()) {
        this.skipNL();
        if (this.check('PUNCTUATION', '}')) break;
        const fname = this.consume('IDENTIFIER').value;
        this.consume('OPERATOR', ':');
        const ftype = this.parseType();
        fields.push({ type: 'Parameter', name: fname, dataType: ftype, required: true });
        this.skipNL();
      }
      this.consume('PUNCTUATION', '}');
      payload = { fields };
    } else if (this.check('IDENTIFIER') || this.check('KEYWORD')) {
      payload = this.parseType();
    }
    return { type: 'OutboxEvent', name, channel, payload };
  }

  private parseType(): TypeNode {
    const name = this.advance().value;
    let generic: TypeNode | undefined;
    if (this.check('OPERATOR', '<')) { this.advance(); generic = this.parseType(); this.consume('OPERATOR', '>'); }
    const nullable = this.check('OPERATOR', '?') ? (this.advance(), true) : false;
    return { type: 'Type', name, generic, nullable };
  }

  private parseBehavior(): BehaviorNode {
    if (this.check('KEYWORD', 'behavior')) this.advance();
    this.consume('KEYWORD', 'on');
    const trigger = this.parseTrigger();
    const guards: ExpressionNode[] = [];
    while (this.check('KEYWORD', 'guard') || this.check('KEYWORD', 'when')) { this.advance(); guards.push(this.parseExpr()); }
    const actions: ActionNode[] = [];
    if (this.check('PUNCTUATION', '{')) {
      this.advance(); this.skipNL();
      while (!this.check('PUNCTUATION', '}') && !this.isEnd()) { this.skipNL(); if (this.check('PUNCTUATION', '}')) break; actions.push(this.parseAction()); this.skipNL(); }
      this.consume('PUNCTUATION', '}');
    } else if (this.check('KEYWORD', 'then') || this.check('OPERATOR', '=>')) { this.advance(); actions.push(this.parseAction()); }
    return { type: 'Behavior', name: trigger.event, trigger, actions, guards: guards.length ? guards : undefined };
  }

  private parseTrigger(): TriggerNode {
    const event = this.consume('IDENTIFIER').value;
    let parameters: string[] | undefined;
    if (this.check('PUNCTUATION', '(')) {
      this.advance(); parameters = [];
      while (!this.check('PUNCTUATION', ')') && !this.isEnd()) { parameters.push(this.consume('IDENTIFIER').value); if (this.check('PUNCTUATION', ',')) this.advance(); }
      this.consume('PUNCTUATION', ')');
    }
    return { type: 'Trigger', event, parameters };
  }

  private parseAction(): ActionNode {
    let kind: ActionNode['kind'] = 'compute', target: string | undefined;
    if (this.check('KEYWORD', 'mutate')) { this.advance(); kind = 'mutate'; target = this.consume('IDENTIFIER').value; this.consume('OPERATOR', '='); }
    else if (this.check('KEYWORD', 'emit')) { this.advance(); kind = 'emit'; }
    else if (this.check('KEYWORD', 'effect')) { this.advance(); kind = 'effect'; }
    else if (this.check('KEYWORD', 'publish')) { this.advance(); kind = 'publish'; }
    else if (this.check('KEYWORD', 'persist')) { this.advance(); kind = 'persist'; }
    return { type: 'Action', kind, target, expression: this.parseExpr() };
  }

  private parseConstraint(): ConstraintNode {
    this.consume('KEYWORD', 'constraint');
    const name = this.consume('IDENTIFIER').value;
    this.consume('OPERATOR', ':');
    const expression = this.parseExpr();
    const message = this.check('STRING') ? this.advance().value : undefined;
    return { type: 'Constraint', name, expression, message };
  }

  private parseFlow(): FlowNode {
    this.consume('KEYWORD', 'flow');
    const name = this.consume('IDENTIFIER').value;
    this.consume('PUNCTUATION', '('); const input = this.parseType(); this.consume('PUNCTUATION', ')');
    this.consume('OPERATOR', '->'); const output = this.parseType();
    this.consume('PUNCTUATION', '{'); this.skipNL();
    const steps: FlowStepNode[] = [];
    while (!this.check('PUNCTUATION', '}') && !this.isEnd()) { this.skipNL(); if (this.check('PUNCTUATION', '}')) break; steps.push(this.parseFlowStep()); this.skipNL(); }
    this.consume('PUNCTUATION', '}');
    return { type: 'Flow', name, input, output, steps };
  }

  private parseFlowStep(): FlowStepNode {
    const operation = this.advance().value;
    let condition: ExpressionNode | undefined;
    if (this.check('KEYWORD', 'when')) { this.advance(); condition = this.parseExpr(); }
    this.consume('OPERATOR', ':');
    return { type: 'FlowStep', operation, expression: this.parseExpr(), condition };
  }

  private parseEffect(): EffectNode {
    this.consume('KEYWORD', 'effect');
    const name = this.consume('IDENTIFIER').value;
    this.consume('OPERATOR', ':');
    const kind = this.advance().value as EffectNode['kind'];
    const config: Record<string, ExpressionNode> = {};
    if (this.check('PUNCTUATION', '{')) {
      this.advance(); this.skipNL();
      while (!this.check('PUNCTUATION', '}') && !this.isEnd()) {
        this.skipNL(); if (this.check('PUNCTUATION', '}')) break;
        const key = this.consume('IDENTIFIER').value; this.consume('OPERATOR', ':'); config[key] = this.parseExpr(); this.skipNL();
      }
      this.consume('PUNCTUATION', '}');
    }
    return { type: 'Effect', name, kind, config };
  }

  private parseExpose(): ExposeNode {
    this.consume('KEYWORD', 'expose');
    const entity = this.consume('IDENTIFIER').value;
    this.consume('KEYWORD', 'as');
    const protocol = this.advance().value as ExposeNode['protocol'];
    let name = entity.toLowerCase();
    let generateServer = false;
    if (this.check('KEYWORD', 'server')) { this.advance(); generateServer = true; }
    if (this.check('STRING')) name = this.advance().value;
    const operations: string[] = [], middleware: string[] = [];
    if (this.check('PUNCTUATION', '{')) {
      this.advance(); this.skipNL();
      while (!this.check('PUNCTUATION', '}') && !this.isEnd()) {
        this.skipNL(); if (this.check('PUNCTUATION', '}')) break;
        const val = this.advance().value;
        if (val === 'middleware') { this.consume('OPERATOR', ':'); middleware.push(this.consume('IDENTIFIER').value); }
        else operations.push(val);
        if (this.check('PUNCTUATION', ',')) this.advance();
        this.skipNL();
      }
      this.consume('PUNCTUATION', '}');
    }
    return { type: 'Expose', name, protocol, entity, operations, generateServer, middleware: middleware.length ? middleware : undefined };
  }

  private parseComposition(): CompositionNode {
    this.consume('KEYWORD', 'compose');
    const name = this.consume('IDENTIFIER').value;
    this.consume('PUNCTUATION', '{'); this.skipNL();
    const components: ComponentRefNode[] = [], connections: ConnectionNode[] = [];
    while (!this.check('PUNCTUATION', '}') && !this.isEnd()) {
      this.skipNL(); if (this.check('PUNCTUATION', '}')) break;
      if (this.check('KEYWORD', 'connect')) connections.push(this.parseConnection());
      else components.push(this.parseComponentRef());
      this.skipNL();
    }
    this.consume('PUNCTUATION', '}');
    return { type: 'Composition', name, components, connections };
  }

  private parseComponentRef(): ComponentRefNode {
    const entity = this.consume('IDENTIFIER').value;
    let alias: string | undefined;
    if (this.check('KEYWORD', 'as')) { this.advance(); alias = this.consume('IDENTIFIER').value; }
    return { type: 'ComponentRef', entity, alias };
  }

  private parseConnection(): ConnectionNode {
    this.consume('KEYWORD', 'connect');
    const fromComponent = this.consume('IDENTIFIER').value; this.consume('OPERATOR', '.'); const fromOutput = this.consume('IDENTIFIER').value;
    this.consume('OPERATOR', '->');
    const toComponent = this.consume('IDENTIFIER').value; this.consume('OPERATOR', '.'); const toInput = this.consume('IDENTIFIER').value;
    let transform: ExpressionNode | undefined;
    if (this.check('KEYWORD', 'with')) { this.advance(); transform = this.parseExpr(); }
    return { type: 'Connection', from: { component: fromComponent, output: fromOutput }, to: { component: toComponent, input: toInput }, transform };
  }

  private parseExpr(): ExpressionNode { return this.parseTernary(); }

  private parseTernary(): ExpressionNode {
    let expr = this.parseOr();
    if (this.check('OPERATOR', '?')) { this.advance(); const cons = this.parseExpr(); this.consume('OPERATOR', ':'); const alt = this.parseExpr(); return { type: 'Conditional', condition: expr, consequent: cons, alternate: alt }; }
    return expr;
  }

  private parseOr(): ExpressionNode {
    let left = this.parseAnd();
    while (this.check('OPERATOR', '||') || this.check('KEYWORD', 'or')) { const op = this.advance().value; left = { type: 'BinaryOp', operator: op, left, right: this.parseAnd() }; }
    return left;
  }

  private parseAnd(): ExpressionNode {
    let left = this.parseEquality();
    while (this.check('OPERATOR', '&&') || this.check('KEYWORD', 'and')) { const op = this.advance().value; left = { type: 'BinaryOp', operator: op, left, right: this.parseEquality() }; }
    return left;
  }

  private parseEquality(): ExpressionNode {
    let left = this.parseComparison();
    while (['==', '!='].includes(this.current()?.value || '') || ['is', 'in', 'contains'].includes(this.current()?.value || '')) { const op = this.advance().value; left = { type: 'BinaryOp', operator: op, left, right: this.parseComparison() }; }
    return left;
  }

  private parseComparison(): ExpressionNode {
    let left = this.parseAdditive();
    while (['<', '>', '<=', '>='].includes(this.current()?.value || '')) { const op = this.advance().value; left = { type: 'BinaryOp', operator: op, left, right: this.parseAdditive() }; }
    return left;
  }

  private parseAdditive(): ExpressionNode {
    let left = this.parseMultiplicative();
    while (['+', '-'].includes(this.current()?.value || '')) { const op = this.advance().value; left = { type: 'BinaryOp', operator: op, left, right: this.parseMultiplicative() }; }
    return left;
  }

  private parseMultiplicative(): ExpressionNode {
    let left = this.parseUnary();
    while (['*', '/', '%'].includes(this.current()?.value || '')) { const op = this.advance().value; left = { type: 'BinaryOp', operator: op, left, right: this.parseUnary() }; }
    return left;
  }

  private parseUnary(): ExpressionNode {
    if (['!', '-'].includes(this.current()?.value || '') || this.check('KEYWORD', 'not')) { const op = this.advance().value; return { type: 'UnaryOp', operator: op, operand: this.parseUnary() }; }
    return this.parsePostfix();
  }

  private parsePostfix(): ExpressionNode {
    let expr = this.parsePrimary();
    while (true) {
      if (this.check('OPERATOR', '.') || this.check('OPERATOR', '?.')) { this.advance(); expr = { type: 'MemberAccess', object: expr, property: this.consume('IDENTIFIER').value }; }
      else if (this.check('PUNCTUATION', '(')) {
        this.advance(); const args: ExpressionNode[] = [];
        while (!this.check('PUNCTUATION', ')') && !this.isEnd()) { args.push(this.parseExpr()); if (this.check('PUNCTUATION', ',')) this.advance(); }
        this.consume('PUNCTUATION', ')'); expr = { type: 'Call', callee: expr, arguments: args };
      }
      else if (this.check('PUNCTUATION', '[')) { this.advance(); const idx = this.parseExpr(); this.consume('PUNCTUATION', ']'); expr = { type: 'MemberAccess', object: expr, property: \`[\${(idx as any).value || ''}]\` }; }
      else break;
    }
    return expr;
  }

  private parsePrimary(): ExpressionNode {
    if (this.check('NUMBER')) return { type: 'Literal', value: parseFloat(this.advance().value), dataType: 'number' };
    if (this.check('STRING')) return { type: 'Literal', value: this.advance().value, dataType: 'string' };
    if (this.check('KEYWORD', 'true') || this.check('KEYWORD', 'false')) return { type: 'Literal', value: this.advance().value === 'true', dataType: 'boolean' };
    if (this.check('KEYWORD', 'null')) { this.advance(); return { type: 'Literal', value: null, dataType: 'null' }; }
    if (this.check('PUNCTUATION', '[')) { this.advance(); const els: ExpressionNode[] = []; while (!this.check('PUNCTUATION', ']') && !this.isEnd()) { els.push(this.parseExpr()); if (this.check('PUNCTUATION', ',')) this.advance(); } this.consume('PUNCTUATION', ']'); return { type: 'Array', elements: els }; }
    if (this.check('PUNCTUATION', '{')) { this.advance(); this.skipNL(); const props: { key: string; value: ExpressionNode }[] = []; while (!this.check('PUNCTUATION', '}') && !this.isEnd()) { this.skipNL(); if (this.check('PUNCTUATION', '}')) break; const key = this.check('STRING') ? this.advance().value : this.consume('IDENTIFIER').value; this.consume('OPERATOR', ':'); props.push({ key, value: this.parseExpr() }); if (this.check('PUNCTUATION', ',')) this.advance(); this.skipNL(); } this.consume('PUNCTUATION', '}'); return { type: 'Object', properties: props }; }
    if (this.check('PUNCTUATION', '(')) {
      this.advance();
      const startPos = this.pos;
      const params: string[] = [];
      while (this.check('IDENTIFIER') && !this.isEnd()) { params.push(this.advance().value); if (this.check('PUNCTUATION', ',')) this.advance(); else break; }
      if (this.check('PUNCTUATION', ')')) { this.advance(); if (this.check('OPERATOR', '=>')) { this.advance(); return { type: 'Lambda', parameters: params, body: this.parseExpr() }; } }
      this.pos = startPos;
      const expr = this.parseExpr(); this.consume('PUNCTUATION', ')'); return expr;
    }
    if (this.check('IDENTIFIER') || this.check('KEYWORD', 'user') || this.check('KEYWORD', 'self') || this.check('KEYWORD', 'context')) return { type: 'Identifier', name: this.advance().value };
    throw new Error(\`Unexpected: \${this.current()?.value || 'EOF'}\`);
  }

  private check(type: string, value?: string) { const t = this.current(); return t && t.type === type && (value === undefined || t.value === value); }
  private consume(type: string, value?: string) { if (this.check(type, value)) return this.advance(); throw new Error(\`Expected \${value || type}, got \${this.current()?.value || 'EOF'}\`); }
  private advance() { if (!this.isEnd()) this.pos++; return this.tokens[this.pos - 1]; }
  private current() { return this.tokens[this.pos]; }
  private isEnd() { return this.pos >= this.tokens.length || this.tokens[this.pos]?.type === 'EOF'; }
  private skipNL() { while (this.check('NEWLINE', '\\n')) this.advance(); }
  private sync() { this.advance(); while (!this.isEnd() && !['entity', 'flow', 'effect', 'expose', 'compose', 'module', 'command', 'policy', 'store', 'event'].includes(this.current()?.value || '')) this.advance(); }
}
`;

const COMPILER_GENERATOR_SOURCE = `import { ManifestProgram, EntityNode, ExpressionNode, BehaviorNode, ConstraintNode, CommandNode, RelationshipNode } from './types';

export class StandaloneGenerator {
  private out: string[] = [];
  private indent = 0;

  generate(program: ManifestProgram): string {
    this.out = [];
    this.indent = 0;
    this.emitImports(program);
    this.line();

    for (const store of program.stores) this.genStore(store);
    for (const e of program.entities) { this.genEntity(e); this.line(); }
    for (const c of program.commands) { this.genCommand(c); this.line(); }
    this.emitExports(program);

    return this.out.join('\\n');
  }

  private emitImports(program: ManifestProgram) {
    this.line('// Generated by Manifest Compiler v2.0');
    this.line();
    const imports = ['Observable', 'EventEmitter', 'EventBus', 'setContext', 'getContext', 'MemoryStore', 'LocalStorageStore'];
    if (program.stores.length > 0) imports.push('Store');
    this.line(\`import { \${imports.join(', ')} } from './runtime';\`);
    this.line();
    this.line('type User = { id: string; role?: string; [key: string]: unknown };');
  }

  private genStore(store: any) {
    const storeName = \`\${store.entity}Store\`;
    switch (store.target) {
      case 'memory':
        this.line(\`const \${storeName}: Store<I\${store.entity}> = new MemoryStore();\`);
        break;
      case 'localStorage':
        const key = store.config?.['key'] ? this.genExpr(store.config['key']) : \`"\${store.entity.toLowerCase()}s"\`;
        this.line(\`const \${storeName}: Store<I\${store.entity}> = new LocalStorageStore(\${key});\`);
        break;
      default:
        this.line(\`const \${storeName}: Store<I\${store.entity}> = new MemoryStore();\`);
    }
    this.line();
  }

  private genEntity(e: EntityNode) {
    const iface = \`I\${e.name}\`;
    this.line(\`export interface \${iface} {\`);
    this.in();
    this.line('id: string;');
    for (const p of e.properties) {
      const opt = p.modifiers.includes('required') ? '' : '?';
      this.line(\`\${p.name}\${opt}: \${this.tsType(p.dataType)};\`);
    }
    this.de(); this.line('}');
    this.line();

    this.line(\`export class \${e.name} extends EventEmitter<Record<string, unknown>> {\`);
    this.in();
    this.line('id: string = crypto.randomUUID();');
    for (const p of e.properties) {
      const def = p.defaultValue ? this.genExpr(p.defaultValue) : this.defVal(p.dataType);
      this.line(\`private _\${p.name} = new Observable(\${def});\`);
    }
    this.line();

    for (const p of e.properties) {
      this.line(\`get \${p.name}() { return this._\${p.name}.value; }\`);
      if (!p.modifiers.includes('readonly')) {
        this.line(\`set \${p.name}(v: \${this.tsType(p.dataType)}) {\`);
        this.in();
        this.line(\`this._\${p.name}.set(v);\`);
        this.de(); this.line('}');
      }
    }

    this.line();
    this.line(\`constructor(init?: Partial<\${iface}>) {\`);
    this.in(); this.line('super();');
    this.line('if (init) {');
    this.in();
    this.line('if (init.id) this.id = init.id;');
    for (const p of e.properties) this.line(\`if (init.\${p.name} !== undefined) this._\${p.name}.set(init.\${p.name});\`);
    this.de(); this.line('}');
    this.de(); this.line('}');

    this.line();
    this.line('toJSON(): Record<string, unknown> {');
    this.in(); this.line('return {');
    this.in();
    this.line('id: this.id,');
    for (const p of e.properties) this.line(\`\${p.name}: this.\${p.name},\`);
    this.de(); this.line('};'); this.de(); this.line('}');

    for (const cmd of e.commands) this.genCommandMethod(cmd);

    this.de(); this.line('}');
  }

  private genCommandMethod(cmd: CommandNode) {
    const params = cmd.parameters.map(p => \`\${p.name}\${p.required ? '' : '?'}: \${this.tsType(p.dataType)}\`).join(', ');
    const returnType = cmd.returns ? this.tsType(cmd.returns) : 'void';
    this.line();
    this.line(\`async \${cmd.name}(\${params}): Promise<\${returnType}> {\`);
    this.in();
    if (cmd.guards?.length) {
      for (const g of cmd.guards) {
        this.line(\`if (!(\${this.genExpr(g)})) throw new Error("Guard failed for \${cmd.name}");\`);
      }
    }
    for (const action of cmd.actions) {
      this.line(this.genAction(action));
    }
    if (cmd.emits) {
      for (const ev of cmd.emits) {
        this.line(\`this.emit('\${ev}', { \${cmd.parameters.map(p => p.name).join(', ')} });\`);
      }
    }
    this.de(); this.line('}');
  }

  private genCommand(cmd: CommandNode) {
    const params = cmd.parameters.map(p => \`\${p.name}\${p.required ? '' : '?'}: \${this.tsType(p.dataType)}\`).join(', ');
    const returnType = cmd.returns ? this.tsType(cmd.returns) : 'void';
    this.line(\`export async function \${cmd.name}(\${params}): Promise<\${returnType}> {\`);
    this.in();
    if (cmd.guards?.length) {
      for (const g of cmd.guards) {
        this.line(\`if (!(\${this.genExpr(g)})) throw new Error("Guard failed for \${cmd.name}");\`);
      }
    }
    for (const action of cmd.actions) {
      this.line(this.genAction(action));
    }
    if (cmd.emits) {
      for (const ev of cmd.emits) {
        this.line(\`EventBus.publish('\${ev}', { \${cmd.parameters.map(p => p.name).join(', ')} });\`);
      }
    }
    this.de(); this.line('}');
  }

  private genAction(a: any): string {
    if (a.kind === 'mutate') return \`this.\${a.target} = \${this.genExpr(a.expression)};\`;
    if (a.kind === 'emit') return \`this.emit('event', \${this.genExpr(a.expression)});\`;
    if (a.kind === 'effect') return \`await (\${this.genExpr(a.expression)});\`;
    if (a.kind === 'publish') return \`EventBus.publish('event', \${this.genExpr(a.expression)});\`;
    return \`\${this.genExpr(a.expression)};\`;
  }

  private emitExports(p: ManifestProgram) {
    const exports: string[] = ['setContext', 'getContext', 'EventBus'];
    for (const s of p.stores) exports.push(\`\${s.entity}Store\`);
    if (exports.length) {
      this.line();
      this.line(\`export { \${exports.join(', ')} };\`);
    }
  }

  private genExpr(e: ExpressionNode): string {
    switch (e.type) {
      case 'Literal': return (e as any).dataType === 'string' ? JSON.stringify((e as any).value) : String((e as any).value);
      case 'Identifier': {
        const name = (e as any).name;
        if (name === 'self') return 'this';
        if (name === 'user') return 'getContext().user';
        if (name === 'context') return 'getContext()';
        return name;
      }
      case 'BinaryOp': {
        const op = (e as any).operator;
        const l = this.genExpr((e as any).left);
        const r = this.genExpr((e as any).right);
        const m: Record<string, string> = { 'and': '&&', 'or': '||', 'is': '===', 'contains': '.includes' };
        if (op === 'contains') return \`\${l}.includes(\${r})\`;
        return \`(\${l} \${m[op] || op} \${r})\`;
      }
      case 'UnaryOp': return \`\${(e as any).operator === 'not' ? '!' : (e as any).operator}\${this.genExpr((e as any).operand)}\`;
      case 'Call': return \`\${this.genExpr((e as any).callee)}(\${(e as any).arguments.map((a: ExpressionNode) => this.genExpr(a)).join(', ')})\`;
      case 'MemberAccess': return \`\${this.genExpr((e as any).object)}.\${(e as any).property}\`;
      case 'Conditional': return \`(\${this.genExpr((e as any).condition)} ? \${this.genExpr((e as any).consequent)} : \${this.genExpr((e as any).alternate)})\`;
      case 'Array': return \`[\${(e as any).elements.map((x: ExpressionNode) => this.genExpr(x)).join(', ')}]\`;
      case 'Object': return \`{ \${(e as any).properties.map((p: any) => \`\${p.key}: \${this.genExpr(p.value)}\`).join(', ')} }\`;
      case 'Lambda': return \`(\${(e as any).parameters.join(', ')}) => \${this.genExpr((e as any).body)}\`;
      default: return '/* unknown */';
    }
  }

  private tsType(t: any): string {
    const m: Record<string, string> = { string: 'string', number: 'number', boolean: 'boolean', any: 'unknown', void: 'void', list: 'Array', map: 'Map' };
    let r = m[t.name] || t.name;
    if (t.generic) r += \`<\${this.tsType(t.generic)}>\`;
    if (t.nullable) r += ' | null';
    return r;
  }

  private defVal(t: any): string {
    if (t.nullable) return 'null';
    const d: Record<string, string> = { string: '""', number: '0', boolean: 'false', list: '[]', map: 'new Map()', any: 'null' };
    return d[t.name] || 'null';
  }

  private line(s = '') { this.out.push('  '.repeat(this.indent) + s); }
  private in() { this.indent++; }
  private de() { this.indent = Math.max(0, this.indent - 1); }
}
`;

const COMPILER_INDEX_SOURCE = `export { Lexer } from './lexer';
export { Parser } from './parser';
export { StandaloneGenerator } from './generator';
export * from './types';
`;

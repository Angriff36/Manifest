import JSZip from 'jszip';
import { ProjectFiles } from './types';

export function generateProjectName(source: string): string {
  const moduleMatch = source.match(/module\s+(\w+)/);
  const entityMatch = source.match(/entity\s+(\w+)/);
  const name = moduleMatch?.[1] || entityMatch?.[1] || 'manifest';
  return name.toLowerCase();
}

export function generatePackageJson(projectName: string): string {
  return JSON.stringify({
    name: projectName,
    version: '1.0.0',
    type: 'module',
    scripts: {
      build: 'tsc',
      test: 'vitest run',
      dev: 'tsx src/generated/client.ts'
    },
    devDependencies: {
      typescript: '^5.5.0',
      vitest: '^2.0.0',
      tsx: '^4.0.0'
    }
  }, null, 2);
}

export function generateTsConfig(): string {
  return JSON.stringify({
    compilerOptions: {
      target: 'ES2022',
      module: 'ESNext',
      moduleResolution: 'bundler',
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      declaration: true,
      outDir: './dist',
      rootDir: './src'
    },
    include: ['src/**/*']
  }, null, 2);
}

export function generateReadme(projectName: string): string {
  return `# ${projectName}

Generated by Manifest Compiler v2.0

## Quick Start

\`\`\`bash
npm install
npm run build
npm test
\`\`\`

## Project Structure

- \`src/generated/client.ts\` - Client-side entity classes and logic
- \`src/generated/server.ts\` - Server routes (Hono-based)
- \`src/generated/tests.spec.ts\` - Auto-generated tests from constraints
- \`src/generated/ast.json\` - Parsed AST for debugging
- \`manifest/source.manifest\` - Original Manifest source

## Generated Files

The code in this project was automatically generated from the Manifest DSL.
Edit the \`.manifest\` source and re-compile to regenerate.
`;
}

export function buildFileMap(files: ProjectFiles): Record<string, string> {
  const projectName = generateProjectName(files.source);

  return {
    'src/generated/client.ts': files.clientCode || '// No client code generated',
    'src/generated/server.ts': files.serverCode || '// No server code generated (add "server" to expose declarations)',
    'src/generated/tests.spec.ts': files.testCode || '// No tests generated',
    'src/generated/ast.json': JSON.stringify(files.ast, null, 2) || '{}',
    'manifest/source.manifest': files.source,
    'package.json': generatePackageJson(projectName),
    'tsconfig.json': generateTsConfig(),
    'README.md': generateReadme(projectName)
  };
}

export async function exportZip(files: ProjectFiles): Promise<void> {
  const zip = new JSZip();
  const fileMap = buildFileMap(files);
  const projectName = generateProjectName(files.source);
  const timestamp = new Date().toISOString().slice(0, 10);

  for (const [path, content] of Object.entries(fileMap)) {
    zip.file(path, content);
  }

  const blob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `manifest-${projectName}-${timestamp}.zip`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

export function copyToClipboard(text: string): Promise<void> {
  return navigator.clipboard.writeText(text);
}

export function copyAllFiles(files: ProjectFiles): Promise<void> {
  const fileMap = buildFileMap(files);
  return copyToClipboard(JSON.stringify(fileMap, null, 2));
}

import { ManifestProgram, EntityNode, FlowNode, EffectNode, ExposeNode, CompositionNode, ExpressionNode, BehaviorNode, ConstraintNode } from './types';

export class CodeGenerator {
  private out: string[] = [];
  private indent = 0;

  generate(program: ManifestProgram): string {
    this.out = [];
    this.indent = 0;
    this.emitRuntime();
    for (const e of program.entities) { this.genEntity(e); this.line(); }
    for (const f of program.flows) { this.genFlow(f); this.line(); }
    for (const e of program.effects) { this.genEffect(e); this.line(); }
    for (const x of program.exposures) { this.genExpose(x); this.line(); }
    for (const c of program.compositions) { this.genComposition(c); this.line(); }
    this.emitExports(program);
    return this.out.join('\n');
  }

  private emitRuntime() {
    this.line('// Generated by Manifest Compiler');
    this.line('// Source of truth: Manifest specification, not this generated code');
    this.line();
    this.line('type Subscriber<T> = (value: T) => void;');
    this.line();
    this.line('class Observable<T> {');
    this.in(); this.line('private subs: Set<Subscriber<T>> = new Set();');
    this.line('private _v: T;');
    this.line('constructor(v: T) { this._v = v; }');
    this.line('get value(): T { return this._v; }');
    this.line('set(v: T) { this._v = v; this.subs.forEach(fn => fn(v)); }');
    this.line('subscribe(fn: Subscriber<T>) { this.subs.add(fn); fn(this._v); return () => this.subs.delete(fn); }');
    this.de(); this.line('}');
    this.line();
    this.line('class EventEmitter<T extends Record<string, any>> {');
    this.in(); this.line('private listeners: Map<keyof T, Set<(d: any) => void>> = new Map();');
    this.line('on<K extends keyof T>(e: K, fn: (d: T[K]) => void) { if (!this.listeners.has(e)) this.listeners.set(e, new Set()); this.listeners.get(e)!.add(fn); return () => this.listeners.get(e)?.delete(fn); }');
    this.line('emit<K extends keyof T>(e: K, d: T[K]) { this.listeners.get(e)?.forEach(fn => fn(d)); }');
    this.de(); this.line('}');
    this.line();
  }

  private genEntity(e: EntityNode) {
    const iface = `I${e.name}`;
    this.line(`interface ${iface} {`);
    this.in(); for (const p of e.properties) { const opt = p.modifiers.includes('required') ? '' : '?'; this.line(`${p.name}${opt}: ${this.tsType(p.dataType)};`); }
    this.de(); this.line('}');
    this.line();

    const events = new Set<string>();
    for (const b of e.behaviors) { events.add(b.trigger.event); for (const a of b.actions) if (a.kind === 'emit' && a.expression.type === 'Identifier') events.add((a.expression as any).name); }
    const evtMap = events.size ? `{ ${[...events].map(ev => `${ev}: any`).join('; ')} }` : '{}';

    this.line(`class ${e.name} extends EventEmitter<${evtMap}> {`);
    this.in();
    for (const p of e.properties) { const def = p.defaultValue ? this.genExpr(p.defaultValue) : this.defVal(p.dataType); this.line(`private _${p.name} = new Observable(${def});`); }
    this.line();
    for (const p of e.properties) {
      this.line(`get ${p.name}() { return this._${p.name}.value; }`);
      if (!p.modifiers.includes('readonly')) {
        this.line(`set ${p.name}(v: ${this.tsType(p.dataType)}) {`);
        this.in(); this.genConstraintChecks(e.constraints, p.name); this.line(`this._${p.name}.set(v);`); this.de(); this.line('}');
      }
    }
    this.line();
    this.line(`constructor(init?: Partial<${iface}>) {`);
    this.in(); this.line('super();');
    this.line('if (init) {'); this.in();
    for (const p of e.properties) this.line(`if (init.${p.name} !== undefined) this._${p.name}.set(init.${p.name});`);
    this.de(); this.line('}');
    this.line('this._initBehaviors();');
    this.de(); this.line('}');
    this.line();
    this.line('private _initBehaviors() {');
    this.in(); for (const b of e.behaviors) this.genBehaviorBinding(b); this.de(); this.line('}');
    this.line();
    this.line(`subscribe(prop: keyof ${iface}, fn: (v: any) => void) { return (this as any)[\`_\${prop}\`].subscribe(fn); }`);
    this.line();
    this.line('toJSON() {');
    this.in(); this.line('return {'); this.in();
    for (const p of e.properties) this.line(`${p.name}: this.${p.name},`);
    this.de(); this.line('};'); this.de(); this.line('}');
    for (const b of e.behaviors) if (b.trigger.event !== 'create' && !b.trigger.event.startsWith('_')) this.genBehaviorMethod(b);
    this.de(); this.line('}');
  }

  private genConstraintChecks(constraints: ConstraintNode[], prop: string) {
    for (const c of constraints) {
      const expr = this.genExpr(c.expression);
      if (expr.includes(prop) || expr.includes('this.')) {
        this.line(`if (!(${expr.replace(new RegExp(`this\\.${prop}`, 'g'), 'v')})) throw new Error(${JSON.stringify(c.message || `Constraint '${c.name}' violated`)});`);
      }
    }
  }

  private genBehaviorBinding(b: BehaviorNode) {
    if (b.trigger.event === 'create') { for (const a of b.actions) this.line(this.genAction(a)); return; }
    const params = b.trigger.parameters?.join(', ') || 'd';
    this.line(`this.on('${b.trigger.event}', (${params}) => {`);
    this.in();
    if (b.guards?.length) { const g = b.guards.map(x => `(${this.genExpr(x)})`).join(' && '); this.line(`if (!(${g})) return;`); }
    for (const a of b.actions) this.line(this.genAction(a));
    this.de(); this.line('});');
  }

  private genBehaviorMethod(b: BehaviorNode) {
    const params = b.trigger.parameters || [];
    this.line();
    this.line(`${b.trigger.event}(${params.map(p => `${p}: any`).join(', ')}) {`);
    this.in(); this.line(`this.emit('${b.trigger.event}', ${params.length ? `{ ${params.join(', ')} }` : '{}'});`);
    this.de(); this.line('}');
  }

  private genAction(a: { kind: string; target?: string; expression: ExpressionNode }): string {
    if (a.kind === 'mutate') return `this.${a.target} = ${this.genExpr(a.expression)};`;
    if (a.kind === 'emit') { if (a.expression.type === 'Identifier') return `this.emit('${(a.expression as any).name}', {});`; return `this.emit('event', ${this.genExpr(a.expression)});`; }
    if (a.kind === 'effect') return `await (${this.genExpr(a.expression)});`;
    return `${this.genExpr(a.expression)};`;
  }

  private genFlow(f: FlowNode) {
    this.line(`function ${f.name}(input: ${this.tsType(f.input)}): ${this.tsType(f.output)} {`);
    this.in(); this.line('let _v = input;'); this.line();
    for (const s of f.steps) {
      const expr = this.genExpr(s.expression);
      if (s.condition) { this.line(`if (${this.genExpr(s.condition)}) {`); this.in(); }
      if (s.operation === 'map') this.line(`_v = (${expr})(_v);`);
      else if (s.operation === 'filter') this.line(`if (!(${expr})(_v)) return null as any;`);
      else if (s.operation === 'validate') this.line(`if (!(${expr})(_v)) throw new Error('Validation failed');`);
      else if (s.operation === 'transform') this.line(`_v = ${expr};`);
      else if (s.operation === 'tap') this.line(`(${expr})(_v);`);
      else this.line(`_v = ${expr};`);
      if (s.condition) { this.de(); this.line('}'); }
    }
    this.line(); this.line('return _v as any;'); this.de(); this.line('}');
  }

  private genEffect(e: EffectNode) {
    this.line(`const ${e.name}Effect = {`);
    this.in(); this.line(`kind: '${e.kind}' as const,`);
    if (e.kind === 'http') {
      const url = e.config['url'] ? this.genExpr(e.config['url']) : '""';
      const method = e.config['method'] ? this.genExpr(e.config['method']) : '"GET"';
      this.line(`async execute(data?: any) {`);
      this.in(); this.line(`const res = await fetch(${url}, { method: ${method}, headers: { 'Content-Type': 'application/json' }, body: data ? JSON.stringify(data) : undefined });`);
      this.line('return res.json();'); this.de(); this.line('},');
    } else if (e.kind === 'storage') {
      const key = e.config['key'] ? this.genExpr(e.config['key']) : '"data"';
      this.line(`get() { const d = localStorage.getItem(${key}); return d ? JSON.parse(d) : null; },`);
      this.line(`set(v: any) { localStorage.setItem(${key}, JSON.stringify(v)); },`);
      this.line(`remove() { localStorage.removeItem(${key}); },`);
    } else if (e.kind === 'timer') {
      const interval = e.config['interval'] ? this.genExpr(e.config['interval']) : '1000';
      this.line(`start(cb: () => void) { return setInterval(cb, ${interval}); },`);
      this.line('stop(id: number) { clearInterval(id); },');
    } else {
      this.line('config: {'); this.in();
      for (const [k, v] of Object.entries(e.config)) this.line(`${k}: ${this.genExpr(v)},`);
      this.de(); this.line('},');
      this.line('execute(data?: any) { /* custom */ },');
    }
    this.de(); this.line('};');
  }

  private genExpose(x: ExposeNode) {
    if (x.protocol === 'rest') {
      this.line(`const ${x.name}API = {`);
      this.in(); this.line(`basePath: '/${x.name}',`);
      this.line(`entity: ${x.entity},`);
      const ops = x.operations.length ? x.operations : ['list', 'get', 'create', 'update', 'delete'];
      if (ops.includes('list')) this.line(`async list(q?: Record<string, any>) { const p = q ? '?' + new URLSearchParams(q as any).toString() : ''; return (await fetch(this.basePath + p)).json(); },`);
      if (ops.includes('get')) this.line('async get(id: string) { return (await fetch(`${this.basePath}/${id}`)).json(); },');
      if (ops.includes('create')) this.line(`async create(d: any) { return (await fetch(this.basePath, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(d) })).json(); },`);
      if (ops.includes('update')) this.line(`async update(id: string, d: any) { return (await fetch(\`\${this.basePath}/\${id}\`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(d) })).json(); },`);
      if (ops.includes('delete')) this.line(`async delete(id: string) { return (await fetch(\`\${this.basePath}/\${id}\`, { method: 'DELETE' })).ok; },`);
      this.de(); this.line('};');
    } else if (x.protocol === 'function') {
      this.line(`function create${x.entity}(d: Partial<I${x.entity}>) { return new ${x.entity}(d); }`);
    }
  }

  private genComposition(c: CompositionNode) {
    this.line(`class ${c.name} {`);
    this.in();
    for (const comp of c.components) { const n = comp.alias || comp.entity.toLowerCase(); this.line(`${n}: ${comp.entity};`); }
    this.line();
    this.line('constructor() {'); this.in();
    for (const comp of c.components) { const n = comp.alias || comp.entity.toLowerCase(); this.line(`this.${n} = new ${comp.entity}();`); }
    this.line();
    for (const conn of c.connections) {
      if (conn.transform) this.line(`this.${conn.from.component}.on('${conn.from.output}', (d) => { const t = (${this.genExpr(conn.transform)})(d); this.${conn.to.component}.emit('${conn.to.input}', t); });`);
      else this.line(`this.${conn.from.component}.on('${conn.from.output}', (d) => this.${conn.to.component}.emit('${conn.to.input}', d));`);
    }
    this.de(); this.line('}');
    this.de(); this.line('}');
  }

  private emitExports(p: ManifestProgram) {
    const exports: string[] = [];
    for (const e of p.entities) exports.push(e.name);
    for (const f of p.flows) exports.push(f.name);
    for (const e of p.effects) exports.push(`${e.name}Effect`);
    for (const x of p.exposures) exports.push(x.protocol === 'rest' ? `${x.name}API` : `create${x.entity}`);
    for (const c of p.compositions) exports.push(c.name);
    if (exports.length) { this.line(); this.line(`export { ${exports.join(', ')} };`); }
  }

  private genExpr(e: ExpressionNode): string {
    switch (e.type) {
      case 'Literal': return e.dataType === 'string' ? JSON.stringify(e.value) : String(e.value);
      case 'Identifier': return (e as any).name === 'self' ? 'this' : (e as any).name;
      case 'BinaryOp': { const op = (e as any).operator; const l = this.genExpr((e as any).left); const r = this.genExpr((e as any).right); const m: Record<string, string> = { 'and': '&&', 'or': '||', 'is': '===', 'contains': '.includes' }; if (op === 'contains') return `${l}.includes(${r})`; return `(${l} ${m[op] || op} ${r})`; }
      case 'UnaryOp': return `${(e as any).operator === 'not' ? '!' : (e as any).operator}${this.genExpr((e as any).operand)}`;
      case 'Call': return `${this.genExpr((e as any).callee)}(${(e as any).arguments.map((a: ExpressionNode) => this.genExpr(a)).join(', ')})`;
      case 'MemberAccess': return `${this.genExpr((e as any).object)}.${(e as any).property}`;
      case 'Conditional': return `(${this.genExpr((e as any).condition)} ? ${this.genExpr((e as any).consequent)} : ${this.genExpr((e as any).alternate)})`;
      case 'Array': return `[${(e as any).elements.map((x: ExpressionNode) => this.genExpr(x)).join(', ')}]`;
      case 'Object': return `{ ${(e as any).properties.map((p: any) => `${p.key}: ${this.genExpr(p.value)}`).join(', ')} }`;
      case 'Lambda': return `(${(e as any).parameters.join(', ')}) => ${this.genExpr((e as any).body)}`;
      default: return '/* ? */';
    }
  }

  private tsType(t: { name: string; generic?: any; nullable: boolean }): string {
    const m: Record<string, string> = { string: 'string', number: 'number', boolean: 'boolean', any: 'any', void: 'void', list: 'Array', map: 'Map' };
    let r = m[t.name] || t.name;
    if (t.generic) r += `<${this.tsType(t.generic)}>`;
    if (t.nullable) r += ' | null';
    return r;
  }

  private defVal(t: { name: string; nullable: boolean }): string {
    if (t.nullable) return 'null';
    const d: Record<string, string> = { string: '""', number: '0', boolean: 'false', list: '[]', map: 'new Map()', any: 'null' };
    return d[t.name] || 'null';
  }

  private line(s = '') { this.out.push('  '.repeat(this.indent) + s); }
  private in() { this.indent++; }
  private de() { this.indent = Math.max(0, this.indent - 1); }
}

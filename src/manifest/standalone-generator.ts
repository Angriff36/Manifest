import { ManifestProgram, EntityNode, FlowNode, EffectNode, ExposeNode, CompositionNode, ExpressionNode, BehaviorNode, ConstraintNode, CommandNode, StoreNode, OutboxEventNode, RelationshipNode } from './types';

export class StandaloneGenerator {
  private out: string[] = [];
  private indent = 0;

  generate(program: ManifestProgram): string {
    this.out = [];
    this.indent = 0;

    this.emitImports(program);
    this.line();

    for (const store of program.stores) this.genStore(store);
    for (const e of program.entities) { this.genEntity(e); this.line(); }
    for (const c of program.commands) { this.genCommand(c); this.line(); }
    for (const f of program.flows) { this.genFlow(f); this.line(); }
    for (const e of program.effects) { this.genEffect(e); this.line(); }
    for (const ev of program.events) { this.genOutboxEvent(ev); this.line(); }
    for (const x of program.exposures) { this.genExpose(x, program); this.line(); }
    for (const c of program.compositions) { this.genComposition(c); this.line(); }

    this.emitExports(program);

    return this.out.join('\n');
  }

  private emitImports(program: ManifestProgram) {
    this.line('// Generated by Manifest Compiler v2.0');
    this.line('// This file imports from the runtime module');
    this.line();

    const imports = ['Observable', 'EventEmitter', 'EventBus', 'setContext', 'getContext', 'MemoryStore', 'LocalStorageStore'];
    const hasStores = program.stores.length > 0;
    if (hasStores) {
      imports.push('Store');
    }

    this.line(`import { ${imports.join(', ')} } from './runtime';`);
    this.line();
    this.line('type User = { id: string; role?: string; [key: string]: unknown };');
  }

  private genStore(store: StoreNode) {
    const storeName = `${store.entity}Store`;
    switch (store.target) {
      case 'memory':
        this.line(`const ${storeName}: Store<I${store.entity}> = new MemoryStore();`);
        break;
      case 'localStorage':
        const key = store.config?.['key'] ? this.genExpr(store.config['key']) : `"${store.entity.toLowerCase()}s"`;
        this.line(`const ${storeName}: Store<I${store.entity}> = new LocalStorageStore(${key});`);
        break;
      default:
        this.line(`const ${storeName}: Store<I${store.entity}> = new MemoryStore();`);
    }
    this.line();
  }

  private genEntity(e: EntityNode) {
    const iface = `I${e.name}`;

    this.line(`export interface ${iface} {`);
    this.in();
    this.line('id: string;');
    for (const p of e.properties) {
      const opt = p.modifiers.includes('required') ? '' : '?';
      this.line(`${p.name}${opt}: ${this.tsType(p.dataType)};`);
    }
    for (const cp of e.computedProperties) {
      this.line(`readonly ${cp.name}: ${this.tsType(cp.dataType)};`);
    }
    for (const r of e.relationships) {
      this.line(`${r.name}${r.kind === 'belongsTo' || r.kind === 'ref' ? '?' : ''}: ${this.relationType(r)};`);
    }
    this.de(); this.line('}');
    this.line();

    const events = this.collectEvents(e);
    const evtMap = events.size ? `{ ${[...events].map(ev => `${ev}: unknown`).join('; ')} }` : 'Record<string, unknown>';

    this.line(`export class ${e.name} extends EventEmitter<${evtMap}> {`);
    this.in();

    this.line('id: string = crypto.randomUUID();');
    for (const p of e.properties) {
      const def = p.defaultValue ? this.genExpr(p.defaultValue) : this.defVal(p.dataType);
      this.line(`private _${p.name} = new Observable(${def});`);
    }
    this.line();

    for (const p of e.properties) {
      this.line(`get ${p.name}() { return this._${p.name}.value; }`);
      if (!p.modifiers.includes('readonly')) {
        this.line(`set ${p.name}(v: ${this.tsType(p.dataType)}) {`);
        this.in();
        this.genConstraintChecks(e.constraints, p.name);
        this.line(`const old = this._${p.name}.value;`);
        this.line(`this._${p.name}.set(v);`);
        this.line(`if (old !== v) this._recompute();`);
        this.de(); this.line('}');
      }
    }

    for (const cp of e.computedProperties) {
      this.line(`private _computed_${cp.name}: ${this.tsType(cp.dataType)} = ${this.defVal(cp.dataType)};`);
      this.line(`get ${cp.name}() { return this._computed_${cp.name}; }`);
    }

    for (const r of e.relationships) {
      if (r.kind === 'hasMany') {
        this.line(`private _rel_${r.name}: ${r.target}[] = [];`);
        this.line(`get ${r.name}() { return this._rel_${r.name}; }`);
        this.line(`add${this.capitalize(r.name.replace(/s$/, ''))}(item: ${r.target}) { this._rel_${r.name}.push(item); }`);
      } else {
        this.line(`private _rel_${r.name}: ${r.target} | null = null;`);
        this.line(`get ${r.name}() { return this._rel_${r.name}; }`);
        this.line(`set ${r.name}(v: ${r.target} | null) { this._rel_${r.name} = v; }`);
      }
    }

    this.line();
    this.line(`constructor(init?: Partial<${iface}>) {`);
    this.in(); this.line('super();');
    this.line('if (init) {');
    this.in();
    this.line('if (init.id) this.id = init.id;');
    for (const p of e.properties) this.line(`if (init.${p.name} !== undefined) this._${p.name}.set(init.${p.name});`);
    this.de(); this.line('}');
    this.line('this._initBehaviors();');
    this.line('this._recompute();');
    this.de(); this.line('}');

    this.line();
    this.line('private _recompute() {');
    this.in();
    for (const cp of e.computedProperties) {
      this.line(`this._computed_${cp.name} = ${this.genExpr(cp.expression)};`);
    }
    this.de(); this.line('}');

    this.line();
    this.line('private _initBehaviors() {');
    this.in();
    for (const b of e.behaviors) this.genBehaviorBinding(b);
    this.de(); this.line('}');

    if (e.policies.length > 0) {
      this.line();
      this.line('checkPolicy(action: string, user: User): boolean {');
      this.in();
      this.line('const context = getContext();');
      for (const p of e.policies) {
        const actionCheck = p.action === 'all' ? 'true' : `action === "${p.action}"`;
        this.line(`if (${actionCheck} && !(${this.genExpr(p.expression)})) return false;`);
      }
      this.line('return true;');
      this.de(); this.line('}');
    }

    this.line();
    this.line(`subscribe(prop: keyof ${iface}, fn: (v: unknown) => void) {`);
    this.in();
    this.line(`const obs = (this as Record<string, unknown>)[\`_\${String(prop)}\`];`);
    this.line('if (obs && typeof (obs as Observable<unknown>).subscribe === "function") {');
    this.in();
    this.line('return (obs as Observable<unknown>).subscribe(fn);');
    this.de(); this.line('}');
    this.line('return () => {};');
    this.de(); this.line('}');

    this.line();
    this.line('toJSON(): Record<string, unknown> {');
    this.in(); this.line('return {');
    this.in();
    this.line('id: this.id,');
    for (const p of e.properties) this.line(`${p.name}: this.${p.name},`);
    for (const cp of e.computedProperties) this.line(`${cp.name}: this.${cp.name},`);
    this.de(); this.line('};'); this.de(); this.line('}');

    for (const cmd of e.commands) this.genCommandMethod(cmd);
    for (const b of e.behaviors) {
      if (b.trigger.event !== 'create' && !b.trigger.event.startsWith('_')) {
        this.genBehaviorMethod(b);
      }
    }

    this.de(); this.line('}');
  }

  private collectEvents(e: EntityNode): Set<string> {
    const events = new Set<string>();
    for (const b of e.behaviors) {
      events.add(b.trigger.event);
      for (const a of b.actions) {
        if (a.kind === 'emit' && a.expression.type === 'Identifier') {
          events.add((a.expression as { name: string }).name);
        }
      }
    }
    for (const cmd of e.commands) {
      if (cmd.emits) cmd.emits.forEach(ev => events.add(ev));
    }
    return events;
  }

  private relationType(r: RelationshipNode): string {
    if (r.kind === 'hasMany') return `${r.target}[]`;
    return `${r.target} | null`;
  }

  private genCommandMethod(cmd: CommandNode) {
    const params = cmd.parameters.map(p => `${p.name}${p.required ? '' : '?'}: ${this.tsType(p.dataType)}`).join(', ');
    const returnType = cmd.returns ? this.tsType(cmd.returns) : 'void';

    this.line();
    this.line(`async ${cmd.name}(${params}): Promise<${returnType}> {`);
    this.in();

    if (cmd.guards && cmd.guards.length > 0) {
      for (const g of cmd.guards) {
        this.line(`if (!(${this.genExpr(g)})) throw new Error("Guard failed for ${cmd.name}");`);
      }
    }

    for (const action of cmd.actions) {
      this.line(this.genAction(action));
    }

    if (cmd.emits) {
      for (const ev of cmd.emits) {
        this.line(`this.emit('${ev}', { ${cmd.parameters.map(p => p.name).join(', ')} });`);
      }
    }

    this.de(); this.line('}');
  }

  private genCommand(cmd: CommandNode) {
    const params = cmd.parameters.map(p => `${p.name}${p.required ? '' : '?'}: ${this.tsType(p.dataType)}`).join(', ');
    const returnType = cmd.returns ? this.tsType(cmd.returns) : 'void';

    this.line(`export async function ${cmd.name}(${params}): Promise<${returnType}> {`);
    this.in();

    if (cmd.guards && cmd.guards.length > 0) {
      for (const g of cmd.guards) {
        this.line(`if (!(${this.genExpr(g)})) throw new Error("Guard failed for ${cmd.name}");`);
      }
    }

    for (const action of cmd.actions) {
      this.line(this.genAction(action));
    }

    if (cmd.emits) {
      for (const ev of cmd.emits) {
        this.line(`EventBus.publish('${ev}', { ${cmd.parameters.map(p => p.name).join(', ')} });`);
      }
    }

    this.de(); this.line('}');
  }

  private genOutboxEvent(ev: OutboxEventNode) {
    const payload = ev.payload as { fields?: { name: string; dataType: { name: string } }[] };
    const payloadType = payload.fields
      ? `{ ${payload.fields.map((f) => `${f.name}: ${this.tsType(f.dataType as { name: string; nullable: boolean })}`).join('; ')} }`
      : 'unknown';

    this.line(`export interface ${ev.name}Event ${payloadType}`);
    this.line();
    this.line(`export const publish${ev.name} = (data: ${ev.name}Event) => {`);
    this.in();
    this.line(`EventBus.publish('${ev.channel}', data);`);
    this.de(); this.line('};');
    this.line();
    this.line(`export const subscribe${ev.name} = (fn: (data: ${ev.name}Event) => void) => {`);
    this.in();
    this.line(`return EventBus.subscribe('${ev.channel}', fn as (d: unknown) => void);`);
    this.de(); this.line('};');
  }

  private genConstraintChecks(constraints: ConstraintNode[], prop: string) {
    for (const c of constraints) {
      const expr = this.genExpr(c.expression);
      if (expr.includes(prop) || expr.includes('this.')) {
        this.line(`if (!(${expr.replace(new RegExp(`this\\.${prop}`, 'g'), 'v')})) throw new Error(${JSON.stringify(c.message || `Constraint '${c.name}' violated`)});`);
      }
    }
  }

  private genBehaviorBinding(b: BehaviorNode) {
    if (b.trigger.event === 'create') {
      for (const a of b.actions) this.line(this.genAction(a));
      return;
    }
    const params = b.trigger.parameters?.join(', ') || 'd';
    this.line(`this.on('${b.trigger.event}', (${params}) => {`);
    this.in();
    if (b.guards?.length) {
      const g = b.guards.map(x => `(${this.genExpr(x)})`).join(' && ');
      this.line(`if (!(${g})) return;`);
    }
    for (const a of b.actions) this.line(this.genAction(a));
    this.de(); this.line('});');
  }

  private genBehaviorMethod(b: BehaviorNode) {
    const params = b.trigger.parameters || [];
    this.line();
    this.line(`${b.trigger.event}(${params.map(p => `${p}: unknown`).join(', ')}) {`);
    this.in();
    this.line(`this.emit('${b.trigger.event}', ${params.length ? `{ ${params.join(', ')} }` : '{}'});`);
    this.de(); this.line('}');
  }

  private genAction(a: { kind: string; target?: string; expression: ExpressionNode }): string {
    if (a.kind === 'mutate') return `this.${a.target} = ${this.genExpr(a.expression)};`;
    if (a.kind === 'emit') {
      if (a.expression.type === 'Identifier') {
        return `this.emit('${(a.expression as { name: string }).name}', {});`;
      }
      return `this.emit('event', ${this.genExpr(a.expression)});`;
    }
    if (a.kind === 'effect') return `await (${this.genExpr(a.expression)});`;
    if (a.kind === 'publish') return `EventBus.publish('event', ${this.genExpr(a.expression)});`;
    if (a.kind === 'persist') return `await ${a.target}Store.update(this.id, this.toJSON());`;
    return `${this.genExpr(a.expression)};`;
  }

  private genFlow(f: FlowNode) {
    this.line(`export function ${f.name}(input: ${this.tsType(f.input)}): ${this.tsType(f.output)} {`);
    this.in(); this.line('let _v = input;'); this.line();
    for (const s of f.steps) {
      const expr = this.genExpr(s.expression);
      if (s.condition) { this.line(`if (${this.genExpr(s.condition)}) {`); this.in(); }
      if (s.operation === 'map') this.line(`_v = (${expr})(_v);`);
      else if (s.operation === 'filter') this.line(`if (!(${expr})(_v)) return null as unknown as ${this.tsType(f.output)};`);
      else if (s.operation === 'validate') this.line(`if (!(${expr})(_v)) throw new Error('Validation failed');`);
      else if (s.operation === 'transform') this.line(`_v = ${expr};`);
      else if (s.operation === 'tap') this.line(`(${expr})(_v);`);
      else this.line(`_v = ${expr};`);
      if (s.condition) { this.de(); this.line('}'); }
    }
    this.line(); this.line(`return _v as unknown as ${this.tsType(f.output)};`);
    this.de(); this.line('}');
  }

  private genEffect(e: EffectNode) {
    this.line(`export const ${e.name}Effect = {`);
    this.in(); this.line(`kind: '${e.kind}' as const,`);
    if (e.kind === 'http') {
      const url = e.config['url'] ? this.genExpr(e.config['url']) : '""';
      const method = e.config['method'] ? this.genExpr(e.config['method']) : '"GET"';
      this.line(`async execute(data?: unknown) {`);
      this.in();
      this.line(`const res = await fetch(${url}, { method: ${method}, headers: { 'Content-Type': 'application/json' }, body: data ? JSON.stringify(data) : undefined });`);
      this.line('return res.json();');
      this.de(); this.line('},');
    } else if (e.kind === 'storage') {
      const key = e.config['key'] ? this.genExpr(e.config['key']) : '"data"';
      this.line(`get() { const d = localStorage.getItem(${key}); return d ? JSON.parse(d) : null; },`);
      this.line(`set(v: unknown) { localStorage.setItem(${key}, JSON.stringify(v)); },`);
      this.line(`remove() { localStorage.removeItem(${key}); },`);
    } else if (e.kind === 'timer') {
      const interval = e.config['interval'] ? this.genExpr(e.config['interval']) : '1000';
      this.line(`start(cb: () => void) { return setInterval(cb, ${interval}); },`);
      this.line('stop(id: number) { clearInterval(id); },');
    } else {
      this.line('config: {'); this.in();
      for (const [k, v] of Object.entries(e.config)) this.line(`${k}: ${this.genExpr(v)},`);
      this.de(); this.line('},');
      this.line('execute(_data?: unknown) { /* custom */ },');
    }
    this.de(); this.line('};');
  }

  private genExpose(x: ExposeNode, _program: ManifestProgram) {
    if (x.protocol === 'rest') {
      this.line(`export const ${x.name}API = {`);
      this.in(); this.line(`basePath: '/${x.name}',`);
      this.line(`entity: '${x.entity}',`);
      const ops = x.operations.length ? x.operations : ['list', 'get', 'create', 'update', 'delete'];
      if (ops.includes('list')) this.line(`async list() { return ${x.entity}Store.getAll(); },`);
      if (ops.includes('get')) this.line(`async get(id: string) { return ${x.entity}Store.getById(id); },`);
      if (ops.includes('create')) this.line(`async create(d: Partial<I${x.entity}>) { return ${x.entity}Store.create(d); },`);
      if (ops.includes('update')) this.line(`async update(id: string, d: Partial<I${x.entity}>) { return ${x.entity}Store.update(id, d); },`);
      if (ops.includes('delete')) this.line(`async delete(id: string) { return ${x.entity}Store.delete(id); },`);
      this.de(); this.line('};');
    } else if (x.protocol === 'function') {
      this.line(`export function create${x.entity}(d: Partial<I${x.entity}>) { return new ${x.entity}(d); }`);
    }
  }

  private genComposition(c: CompositionNode) {
    this.line(`export class ${c.name} {`);
    this.in();
    for (const comp of c.components) {
      const n = comp.alias || comp.entity.toLowerCase();
      this.line(`${n}: ${comp.entity};`);
    }
    this.line();
    this.line('constructor() {');
    this.in();
    for (const comp of c.components) {
      const n = comp.alias || comp.entity.toLowerCase();
      this.line(`this.${n} = new ${comp.entity}();`);
    }
    this.line();
    for (const conn of c.connections) {
      if (conn.transform) {
        this.line(`this.${conn.from.component}.on('${conn.from.output}', (d) => { const t = (${this.genExpr(conn.transform)})(d); this.${conn.to.component}.emit('${conn.to.input}', t); });`);
      } else {
        this.line(`this.${conn.from.component}.on('${conn.from.output}', (d) => this.${conn.to.component}.emit('${conn.to.input}', d));`);
      }
    }
    this.de(); this.line('}');
    this.de(); this.line('}');
  }

  private emitExports(p: ManifestProgram) {
    const exports: string[] = ['setContext', 'getContext', 'EventBus'];
    for (const s of p.stores) exports.push(`${s.entity}Store`);
    if (exports.length) {
      this.line();
      this.line(`export { ${exports.join(', ')} };`);
    }
  }

  private genExpr(e: ExpressionNode): string {
    switch (e.type) {
      case 'Literal':
        return (e as { dataType: string }).dataType === 'string'
          ? JSON.stringify((e as { value: unknown }).value)
          : String((e as { value: unknown }).value);
      case 'Identifier': {
        const name = (e as { name: string }).name;
        if (name === 'self') return 'this';
        if (name === 'user') return 'getContext().user';
        if (name === 'context') return 'getContext()';
        return name;
      }
      case 'BinaryOp': {
        const op = (e as { operator: string }).operator;
        const l = this.genExpr((e as { left: ExpressionNode }).left);
        const r = this.genExpr((e as { right: ExpressionNode }).right);
        const m: Record<string, string> = { 'and': '&&', 'or': '||', 'is': '===', 'contains': '.includes' };
        if (op === 'contains') return `${l}.includes(${r})`;
        return `(${l} ${m[op] || op} ${r})`;
      }
      case 'UnaryOp': {
        const op = (e as { operator: string }).operator;
        return `${op === 'not' ? '!' : op}${this.genExpr((e as { operand: ExpressionNode }).operand)}`;
      }
      case 'Call': {
        const callee = this.genExpr((e as { callee: ExpressionNode }).callee);
        const args = (e as { arguments: ExpressionNode[] }).arguments.map(a => this.genExpr(a)).join(', ');
        return `${callee}(${args})`;
      }
      case 'MemberAccess':
        return `${this.genExpr((e as { object: ExpressionNode }).object)}.${(e as { property: string }).property}`;
      case 'Conditional': {
        const cond = this.genExpr((e as { condition: ExpressionNode }).condition);
        const cons = this.genExpr((e as { consequent: ExpressionNode }).consequent);
        const alt = this.genExpr((e as { alternate: ExpressionNode }).alternate);
        return `(${cond} ? ${cons} : ${alt})`;
      }
      case 'Array':
        return `[${(e as { elements: ExpressionNode[] }).elements.map(x => this.genExpr(x)).join(', ')}]`;
      case 'Object':
        return `{ ${(e as { properties: { key: string; value: ExpressionNode }[] }).properties.map(p => `${p.key}: ${this.genExpr(p.value)}`).join(', ')} }`;
      case 'Lambda':
        return `(${(e as { parameters: string[] }).parameters.join(', ')}) => ${this.genExpr((e as { body: ExpressionNode }).body)}`;
      default:
        return '/* unknown */';
    }
  }

  private tsType(t: { name: string; generic?: { name: string; nullable: boolean }; nullable: boolean }): string {
    const m: Record<string, string> = { string: 'string', number: 'number', boolean: 'boolean', any: 'unknown', void: 'void', list: 'Array', map: 'Map' };
    let r = m[t.name] || t.name;
    if (t.generic) r += `<${this.tsType(t.generic)}>`;
    if (t.nullable) r += ' | null';
    return r;
  }

  private defVal(t: { name: string; nullable: boolean }): string {
    if (t.nullable) return 'null';
    const d: Record<string, string> = { string: '""', number: '0', boolean: 'false', list: '[]', map: 'new Map()', any: 'null' };
    return d[t.name] || 'null';
  }

  private capitalize(s: string): string {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }

  private line(s = '') { this.out.push('  '.repeat(this.indent) + s); }
  private in() { this.indent++; }
  private de() { this.indent = Math.max(0, this.indent - 1); }
}

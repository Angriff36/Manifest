import { COMPILER_VERSION, SCHEMA_VERSION } from './version';
export class StandaloneGenerator {
    out = [];
    indent = 0;
    provenance; // Definitely assigned in generate()
    generate(program) {
        this.out = [];
        this.indent = 0;
        this.provenance = {
            compilerVersion: COMPILER_VERSION,
            schemaVersion: SCHEMA_VERSION,
            generatedAt: new Date().toISOString(),
        };
        this.emitImports(program);
        this.line();
        for (const store of program.stores)
            this.genStore(store);
        for (const e of program.entities) {
            this.genEntity(e);
            this.line();
        }
        for (const c of program.commands) {
            this.genCommand(c);
            this.line();
        }
        for (const f of program.flows) {
            this.genFlow(f);
            this.line();
        }
        for (const e of program.effects) {
            this.genEffect(e);
            this.line();
        }
        for (const ev of program.events) {
            this.genOutboxEvent(ev);
            this.line();
        }
        for (const x of program.exposures) {
            this.genExpose(x);
            this.line();
        }
        for (const c of program.compositions) {
            this.genComposition(c);
            this.line();
        }
        this.emitExports(program);
        return this.out.join('\n');
    }
    emitImports(program) {
        this.line('// Generated by Manifest Compiler v2.0');
        this.line('// This code is a PROJECTION from a Manifest source file.');
        this.line('// The IR (Intermediate Representation) is the single source of truth.');
        this.line('// This generated code should not be edited manually.');
        this.line('//');
        this.line(`// Provenance:`);
        this.line(`//   Compiler Version: ${this.provenance.compilerVersion}`);
        this.line(`//   Schema Version: ${this.provenance.schemaVersion}`);
        this.line(`//   Generated At: ${this.provenance.generatedAt}`);
        this.line('//');
        this.line('// This file imports from the runtime module');
        this.line();
        const imports = ['Observable', 'EventEmitter', 'EventBus', 'setContext', 'getContext', 'MemoryStore', 'LocalStorageStore'];
        const hasStores = program.stores.length > 0;
        if (hasStores) {
            imports.push('Store');
        }
        this.line(`import { ${imports.join(', ')} } from './runtime';`);
        this.line();
        this.line('type User = { id: string; role?: string; [key: string]: unknown };');
    }
    genStore(store) {
        const storeName = `${store.entity}Store`;
        switch (store.target) {
            case 'memory':
                this.line(`const ${storeName}: Store<I${store.entity}> = new MemoryStore();`);
                break;
            case 'localStorage': {
                const key = store.config?.['key'] ? this.genExpr(store.config['key']) : `"${store.entity.toLowerCase()}s"`;
                this.line(`const ${storeName}: Store<I${store.entity}> = new LocalStorageStore(${key});`);
                break;
            }
            default:
                this.line(`const ${storeName}: Store<I${store.entity}> = new MemoryStore();`);
        }
        this.line();
    }
    genEntity(e) {
        const iface = `I${e.name}`;
        this.line(`export interface ${iface} {`);
        this.in();
        this.line('id: string;');
        for (const p of e.properties) {
            const opt = p.modifiers.includes('required') ? '' : '?';
            this.line(`${p.name}${opt}: ${this.tsType(p.dataType)};`);
        }
        for (const cp of e.computedProperties) {
            this.line(`readonly ${cp.name}: ${this.tsType(cp.dataType)};`);
        }
        for (const r of e.relationships) {
            this.line(`${r.name}${r.kind === 'belongsTo' || r.kind === 'ref' ? '?' : ''}: ${this.relationType(r)};`);
        }
        this.de();
        this.line('}');
        this.line();
        const events = this.collectEvents(e);
        const evtMap = events.size ? `{ ${[...events].map(ev => `${ev}: unknown`).join('; ')} }` : 'Record<string, unknown>';
        this.line(`export class ${e.name} extends EventEmitter<${evtMap}> {`);
        this.in();
        this.line('id: string = crypto.randomUUID();');
        for (const p of e.properties) {
            const def = p.defaultValue ? this.genExpr(p.defaultValue) : this.defVal(p.dataType);
            this.line(`private _${p.name} = new Observable(${def});`);
        }
        this.line();
        for (const p of e.properties) {
            this.line(`get ${p.name}() { return this._${p.name}.value; }`);
            if (!p.modifiers.includes('readonly')) {
                this.line(`set ${p.name}(v: ${this.tsType(p.dataType)}) {`);
                this.in();
                this.genConstraintChecks(e.constraints, p.name);
                this.line(`const old = this._${p.name}.value;`);
                this.line(`this._${p.name}.set(v);`);
                this.line(`if (old !== v) this._recompute();`);
                this.de();
                this.line('}');
            }
        }
        for (const cp of e.computedProperties) {
            this.line(`private _computed_${cp.name}: ${this.tsType(cp.dataType)} = ${this.defVal(cp.dataType)};`);
            this.line(`get ${cp.name}() { return this._computed_${cp.name}; }`);
        }
        for (const r of e.relationships) {
            if (r.kind === 'hasMany') {
                this.line(`private _rel_${r.name}: ${r.target}[] = [];`);
                this.line(`get ${r.name}() { return this._rel_${r.name}; }`);
                this.line(`add${this.capitalize(r.name.replace(/s$/, ''))}(item: ${r.target}) { this._rel_${r.name}.push(item); }`);
            }
            else {
                this.line(`private _rel_${r.name}: ${r.target} | null = null;`);
                this.line(`get ${r.name}() { return this._rel_${r.name}; }`);
                this.line(`set ${r.name}(v: ${r.target} | null) { this._rel_${r.name} = v; }`);
            }
        }
        this.line();
        this.line(`constructor(init?: Partial<${iface}>) {`);
        this.in();
        this.line('super();');
        this.line('if (init) {');
        this.in();
        this.line('if (init.id) this.id = init.id;');
        for (const p of e.properties)
            this.line(`if (init.${p.name} !== undefined) this._${p.name}.set(init.${p.name});`);
        this.de();
        this.line('}');
        this.line('this._initBehaviors();');
        this.line('this._recompute();');
        this.de();
        this.line('}');
        this.line();
        this.line('private _recompute() {');
        this.in();
        for (const cp of e.computedProperties) {
            this.line(`this._computed_${cp.name} = ${this.genExpr(cp.expression)};`);
        }
        this.de();
        this.line('}');
        this.line();
        this.line('private _initBehaviors() {');
        this.in();
        for (const b of e.behaviors)
            this.genBehaviorBinding(b);
        this.de();
        this.line('}');
        if (e.policies.length > 0) {
            this.line();
            this.line('checkPolicy(action: string, user: User): boolean {');
            this.in();
            this.line('const context = getContext();');
            for (const p of e.policies) {
                const actionCheck = p.action === 'all' ? 'true' : `action === "${p.action}"`;
                this.line(`if (${actionCheck} && !(${this.genExpr(p.expression)})) return false;`);
            }
            this.line('return true;');
            this.de();
            this.line('}');
        }
        this.line();
        this.line(`subscribe(prop: keyof ${iface}, fn: (v: unknown) => void) {`);
        this.in();
        this.line(`const obs = (this as Record<string, unknown>)[\`_\${String(prop)}\`];`);
        this.line('if (obs && typeof (obs as Observable<unknown>).subscribe === "function") {');
        this.in();
        this.line('return (obs as Observable<unknown>).subscribe(fn);');
        this.de();
        this.line('}');
        this.line('return () => {};');
        this.de();
        this.line('}');
        this.line();
        this.line('toJSON(): Record<string, unknown> {');
        this.in();
        this.line('return {');
        this.in();
        this.line('id: this.id,');
        for (const p of e.properties)
            this.line(`${p.name}: this.${p.name},`);
        for (const cp of e.computedProperties)
            this.line(`${cp.name}: this.${cp.name},`);
        this.de();
        this.line('};');
        this.de();
        this.line('}');
        for (const cmd of e.commands)
            this.genCommandMethod(cmd, e);
        for (const b of e.behaviors) {
            if (b.trigger.event !== 'create' && !b.trigger.event.startsWith('_')) {
                this.genBehaviorMethod(b);
            }
        }
        this.de();
        this.line('}');
    }
    collectEvents(e) {
        const events = new Set();
        for (const b of e.behaviors) {
            events.add(b.trigger.event);
            for (const a of b.actions) {
                if (a.kind === 'emit' && a.expression.type === 'Identifier') {
                    events.add(a.expression.name);
                }
            }
        }
        for (const cmd of e.commands) {
            if (cmd.emits)
                cmd.emits.forEach(ev => events.add(ev));
        }
        return events;
    }
    relationType(r) {
        if (r.kind === 'hasMany')
            return `${r.target}[]`;
        return `${r.target} | null`;
    }
    genCommandMethod(cmd, entity) {
        const params = cmd.parameters.map(p => `${p.name}${p.required ? '' : '?'}: ${this.tsType(p.dataType)}`).join(', ');
        // Return the last action result type if specified, otherwise infer from actions or default to unknown
        const returnType = cmd.returns ? this.tsType(cmd.returns) : 'unknown';
        this.line();
        this.line(`async ${cmd.name}(${params}): Promise<${returnType}> {`);
        this.in();
        // Check policies first (if entity has policies with execute/all action)
        if (entity && entity.policies.length > 0) {
            this.line('// Policy checks');
            const hasRelevantPolicies = entity.policies.some(p => p.action === 'all' || p.action === 'execute');
            if (hasRelevantPolicies) {
                this.line(`const user = getContext().user;`);
                for (const p of entity.policies) {
                    if (p.action !== 'all' && p.action !== 'execute')
                        continue;
                    this.line(`if (!(${this.genExpr(p.expression)})) throw new Error(${JSON.stringify(p.message || `Denied by policy '${p.name}'`)});`);
                }
            }
        }
        // Check guards
        if (cmd.guards && cmd.guards.length > 0) {
            this.line('// Guard checks');
            for (const g of cmd.guards) {
                this.line(`if (!(${this.genExpr(g)})) throw new Error("Guard failed for ${cmd.name}");`);
            }
        }
        // Execute actions and capture the last result
        if (cmd.actions.length > 0) {
            this.line('let _result: unknown;');
            for (const action of cmd.actions) {
                this.line(`_result = ${this.genAction(action)};`);
            }
        }
        if (cmd.emits) {
            for (const ev of cmd.emits) {
                this.line(`this.emit('${ev}', { ${cmd.parameters.map(p => p.name).join(', ')} });`);
            }
        }
        // Return the last action result
        if (cmd.actions.length > 0) {
            this.line(`return _result as ${returnType};`);
        }
        this.de();
        this.line('}');
    }
    genCommand(cmd) {
        const params = cmd.parameters.map(p => `${p.name}${p.required ? '' : '?'}: ${this.tsType(p.dataType)}`).join(', ');
        const returnType = cmd.returns ? this.tsType(cmd.returns) : 'unknown';
        this.line(`export async function ${cmd.name}(${params}): Promise<${returnType}> {`);
        this.in();
        if (cmd.guards && cmd.guards.length > 0) {
            this.line('// Guard checks');
            for (const g of cmd.guards) {
                this.line(`if (!(${this.genExpr(g)})) throw new Error("Guard failed for ${cmd.name}");`);
            }
        }
        // Execute actions and capture the last result
        if (cmd.actions.length > 0) {
            this.line('let _result: unknown;');
            for (const action of cmd.actions) {
                this.line(`_result = ${this.genAction(action)};`);
            }
        }
        if (cmd.emits) {
            for (const ev of cmd.emits) {
                this.line(`EventBus.publish('${ev}', { ${cmd.parameters.map(p => p.name).join(', ')} });`);
            }
        }
        // Return the last action result
        if (cmd.actions.length > 0) {
            this.line(`return _result as ${returnType};`);
        }
        this.de();
        this.line('}');
    }
    genOutboxEvent(ev) {
        const payload = ev.payload;
        const payloadType = payload.fields
            ? `{ ${payload.fields.map((f) => `${f.name}: ${this.tsType(f.dataType)}`).join('; ')} }`
            : 'unknown';
        this.line(`export interface ${ev.name}Event ${payloadType}`);
        this.line();
        this.line(`export const publish${ev.name} = (data: ${ev.name}Event) => {`);
        this.in();
        this.line(`EventBus.publish('${ev.channel}', data);`);
        this.de();
        this.line('};');
        this.line();
        this.line(`export const subscribe${ev.name} = (fn: (data: ${ev.name}Event) => void) => {`);
        this.in();
        this.line(`return EventBus.subscribe('${ev.channel}', fn as (d: unknown) => void);`);
        this.de();
        this.line('};');
    }
    genConstraintChecks(constraints, prop) {
        for (const c of constraints) {
            const expr = this.genExpr(c.expression);
            if (expr.includes(prop) || expr.includes('this.')) {
                this.line(`if (!(${expr.replace(new RegExp(`this\\.${prop}`, 'g'), 'v')})) throw new Error(${JSON.stringify(c.message || `Constraint '${c.name}' violated`)});`);
            }
        }
    }
    genBehaviorBinding(b) {
        if (b.trigger.event === 'create') {
            for (const a of b.actions)
                this.line(this.genAction(a));
            return;
        }
        const params = b.trigger.parameters?.join(', ') || 'd';
        this.line(`this.on('${b.trigger.event}', (${params}) => {`);
        this.in();
        if (b.guards?.length) {
            const g = b.guards.map(x => `(${this.genExpr(x)})`).join(' && ');
            this.line(`if (!(${g})) return;`);
        }
        for (const a of b.actions)
            this.line(this.genAction(a));
        this.de();
        this.line('});');
    }
    genBehaviorMethod(b) {
        const params = b.trigger.parameters || [];
        this.line();
        this.line(`${b.trigger.event}(${params.map(p => `${p}: unknown`).join(', ')}) {`);
        this.in();
        this.line(`this.emit('${b.trigger.event}', ${params.length ? `{ ${params.join(', ')} }` : '{}'});`);
        this.de();
        this.line('}');
    }
    genAction(a) {
        if (a.kind === 'mutate')
            return `this.${a.target} = ${this.genExpr(a.expression)};`;
        if (a.kind === 'emit') {
            if (a.expression.type === 'Identifier') {
                return `this.emit('${a.expression.name}', {});`;
            }
            return `this.emit('event', ${this.genExpr(a.expression)});`;
        }
        if (a.kind === 'effect')
            return `await (${this.genExpr(a.expression)});`;
        if (a.kind === 'publish')
            return `EventBus.publish('event', ${this.genExpr(a.expression)});`;
        if (a.kind === 'persist')
            return `await ${a.target}Store.update(this.id, this.toJSON());`;
        return `${this.genExpr(a.expression)};`;
    }
    genFlow(f) {
        this.line(`export function ${f.name}(input: ${this.tsType(f.input)}): ${this.tsType(f.output)} {`);
        this.in();
        this.line('let _v = input;');
        this.line();
        for (const s of f.steps) {
            const expr = this.genExpr(s.expression);
            if (s.condition) {
                this.line(`if (${this.genExpr(s.condition)}) {`);
                this.in();
            }
            if (s.operation === 'map')
                this.line(`_v = (${expr})(_v);`);
            else if (s.operation === 'filter')
                this.line(`if (!(${expr})(_v)) return null as unknown as ${this.tsType(f.output)};`);
            else if (s.operation === 'validate')
                this.line(`if (!(${expr})(_v)) throw new Error('Validation failed');`);
            else if (s.operation === 'transform')
                this.line(`_v = ${expr};`);
            else if (s.operation === 'tap')
                this.line(`(${expr})(_v);`);
            else
                this.line(`_v = ${expr};`);
            if (s.condition) {
                this.de();
                this.line('}');
            }
        }
        this.line();
        this.line(`return _v as unknown as ${this.tsType(f.output)};`);
        this.de();
        this.line('}');
    }
    genEffect(e) {
        this.line(`export const ${e.name}Effect = {`);
        this.in();
        this.line(`kind: '${e.kind}' as const,`);
        if (e.kind === 'http') {
            const url = e.config['url'] ? this.genExpr(e.config['url']) : '""';
            const method = e.config['method'] ? this.genExpr(e.config['method']) : '"GET"';
            this.line(`async execute(data?: unknown) {`);
            this.in();
            this.line(`const res = await fetch(${url}, { method: ${method}, headers: { 'Content-Type': 'application/json' }, body: data ? JSON.stringify(data) : undefined });`);
            this.line('return res.json();');
            this.de();
            this.line('},');
        }
        else if (e.kind === 'storage') {
            const key = e.config['key'] ? this.genExpr(e.config['key']) : '"data"';
            this.line(`get() { const d = localStorage.getItem(${key}); return d ? JSON.parse(d) : null; },`);
            this.line(`set(v: unknown) { localStorage.setItem(${key}, JSON.stringify(v)); },`);
            this.line(`remove() { localStorage.removeItem(${key}); },`);
        }
        else if (e.kind === 'timer') {
            const interval = e.config['interval'] ? this.genExpr(e.config['interval']) : '1000';
            this.line(`start(cb: () => void) { return setInterval(cb, ${interval}); },`);
            this.line('stop(id: number) { clearInterval(id); },');
        }
        else {
            this.line('config: {');
            this.in();
            for (const [k, v] of Object.entries(e.config))
                this.line(`${k}: ${this.genExpr(v)},`);
            this.de();
            this.line('},');
            this.line('execute(_data?: unknown) { /* custom */ },');
        }
        this.de();
        this.line('};');
    }
    genExpose(x) {
        if (x.protocol === 'rest') {
            this.line(`export const ${x.name}API = {`);
            this.in();
            this.line(`basePath: '/${x.name}',`);
            this.line(`entity: '${x.entity}',`);
            const ops = x.operations.length ? x.operations : ['list', 'get', 'create', 'update', 'delete'];
            if (ops.includes('list'))
                this.line(`async list() { return ${x.entity}Store.getAll(); },`);
            if (ops.includes('get'))
                this.line(`async get(id: string) { return ${x.entity}Store.getById(id); },`);
            if (ops.includes('create'))
                this.line(`async create(d: Partial<I${x.entity}>) { return ${x.entity}Store.create(d); },`);
            if (ops.includes('update'))
                this.line(`async update(id: string, d: Partial<I${x.entity}>) { return ${x.entity}Store.update(id, d); },`);
            if (ops.includes('delete'))
                this.line(`async delete(id: string) { return ${x.entity}Store.delete(id); },`);
            this.de();
            this.line('};');
        }
        else if (x.protocol === 'function') {
            this.line(`export function create${x.entity}(d: Partial<I${x.entity}>) { return new ${x.entity}(d); }`);
        }
    }
    genComposition(c) {
        this.line(`export class ${c.name} {`);
        this.in();
        for (const comp of c.components) {
            const n = comp.alias || comp.entity.toLowerCase();
            this.line(`${n}: ${comp.entity};`);
        }
        this.line();
        this.line('constructor() {');
        this.in();
        for (const comp of c.components) {
            const n = comp.alias || comp.entity.toLowerCase();
            this.line(`this.${n} = new ${comp.entity}();`);
        }
        this.line();
        for (const conn of c.connections) {
            if (conn.transform) {
                this.line(`this.${conn.from.component}.on('${conn.from.output}', (d) => { const t = (${this.genExpr(conn.transform)})(d); this.${conn.to.component}.emit('${conn.to.input}', t); });`);
            }
            else {
                this.line(`this.${conn.from.component}.on('${conn.from.output}', (d) => this.${conn.to.component}.emit('${conn.to.input}', d));`);
            }
        }
        this.de();
        this.line('}');
        this.de();
        this.line('}');
    }
    emitExports(p) {
        const exports = ['setContext', 'getContext', 'EventBus'];
        for (const s of p.stores)
            exports.push(`${s.entity}Store`);
        if (exports.length) {
            this.line();
            this.line(`export { ${exports.join(', ')} };`);
        }
    }
    genExpr(e) {
        switch (e.type) {
            case 'Literal':
                return e.dataType === 'string'
                    ? JSON.stringify(e.value)
                    : String(e.value);
            case 'Identifier': {
                const name = e.name;
                if (name === 'self')
                    return 'this';
                if (name === 'user')
                    return 'getContext().user';
                if (name === 'context')
                    return 'getContext()';
                return name;
            }
            case 'BinaryOp': {
                const op = e.operator;
                const l = this.genExpr(e.left);
                const r = this.genExpr(e.right);
                const m = { 'and': '&&', 'or': '||', 'is': '===', 'contains': '.includes' };
                if (op === 'contains')
                    return `${l}.includes(${r})`;
                return `(${l} ${m[op] || op} ${r})`;
            }
            case 'UnaryOp': {
                const op = e.operator;
                return `${op === 'not' ? '!' : op}${this.genExpr(e.operand)}`;
            }
            case 'Call': {
                const callee = this.genExpr(e.callee);
                const args = e.arguments.map(a => this.genExpr(a)).join(', ');
                return `${callee}(${args})`;
            }
            case 'MemberAccess':
                return `${this.genExpr(e.object)}.${e.property}`;
            case 'Conditional': {
                const cond = this.genExpr(e.condition);
                const cons = this.genExpr(e.consequent);
                const alt = this.genExpr(e.alternate);
                return `(${cond} ? ${cons} : ${alt})`;
            }
            case 'Array':
                return `[${e.elements.map(x => this.genExpr(x)).join(', ')}]`;
            case 'Object':
                return `{ ${e.properties.map(p => `${p.key}: ${this.genExpr(p.value)}`).join(', ')} }`;
            case 'Lambda':
                return `(${e.parameters.join(', ')}) => ${this.genExpr(e.body)}`;
            default:
                return '/* unknown */';
        }
    }
    tsType(t) {
        const m = { string: 'string', number: 'number', boolean: 'boolean', any: 'unknown', void: 'void', list: 'Array', map: 'Map' };
        let r = m[t.name] || t.name;
        if (t.generic)
            r += `<${this.tsType(t.generic)}>`;
        if (t.nullable)
            r += ' | null';
        return r;
    }
    defVal(t) {
        if (t.nullable)
            return 'null';
        const d = { string: '""', number: '0', boolean: 'false', list: '[]', map: 'new Map()', any: 'null' };
        return d[t.name] || 'null';
    }
    capitalize(s) {
        return s.charAt(0).toUpperCase() + s.slice(1);
    }
    line(s = '') { this.out.push('  '.repeat(this.indent) + s); }
    in() { this.indent++; }
    de() { this.indent = Math.max(0, this.indent - 1); }
}
//# sourceMappingURL=standalone-generator.js.map